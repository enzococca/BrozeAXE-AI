{% extends "base.html" %}

{% block title %}Morphometric Analysis - Archaeological Classifier{% endblock %}

{% block extra_head %}
<script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
{% endblock %}

{% block content %}
<div class="container">
    <div class="page-header">
        <h1>Morphometric Analysis</h1>
        <p class="subtitle">PCA, clustering, and similarity analysis</p>
    </div>

    <div class="analysis-container">
        <div class="card">
            <h2>Principal Component Analysis (PCA)</h2>
            <div class="form-group">
                <label>Number of Components (leave empty for auto)</label>
                <input type="number" id="pca-components" class="form-input" placeholder="Auto">
            </div>
            <div class="form-group">
                <label>Explained Variance Threshold</label>
                <input type="number" id="pca-variance" class="form-input" value="0.95" step="0.05" min="0.5" max="1.0">
            </div>
            <button onclick="runPCA()" class="btn btn-primary">Run PCA</button>
            <div id="pca-results" class="results-container"></div>
        </div>

        <div class="card">
            <h2>Clustering Analysis</h2>
            <div class="form-group">
                <label>Method</label>
                <select id="cluster-method" class="form-input" onchange="updateClusteringOptions()">
                    <option value="hierarchical">Hierarchical</option>
                    <option value="dbscan">DBSCAN</option>
                </select>
            </div>

            <div id="hierarchical-options">
                <div class="form-group">
                    <label>Number of Clusters</label>
                    <input type="number" id="n-clusters" class="form-input" value="5" min="2">
                </div>
                <div class="form-group">
                    <label>Linkage Method</label>
                    <select id="linkage-method" class="form-input">
                        <option value="ward">Ward</option>
                        <option value="complete">Complete</option>
                        <option value="average">Average</option>
                    </select>
                </div>
            </div>

            <div id="dbscan-options" style="display: none;">
                <div class="form-group">
                    <label>Epsilon (eps)</label>
                    <input type="number" id="eps" class="form-input" value="0.5" step="0.1">
                </div>
                <div class="form-group">
                    <label>Min Samples</label>
                    <input type="number" id="min-samples" class="form-input" value="3" min="2">
                </div>
            </div>

            <button onclick="runClustering()" class="btn btn-primary">Run Clustering</button>
            <div id="clustering-results" class="results-container"></div>
        </div>

        <div class="card full-width">
            <h2>Visualization</h2>
            <div id="viz-container" class="viz-container">
                <p class="text-muted">Run analysis to see visualizations</p>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
function updateClusteringOptions() {
    const method = document.getElementById('cluster-method').value;
    document.getElementById('hierarchical-options').style.display =
        method === 'hierarchical' ? 'block' : 'none';
    document.getElementById('dbscan-options').style.display =
        method === 'dbscan' ? 'block' : 'none';
}

async function runPCA() {
    const components = document.getElementById('pca-components').value;
    const variance = parseFloat(document.getElementById('pca-variance').value);

    const resultsDiv = document.getElementById('pca-results');
    resultsDiv.innerHTML = '<p class="loading">Running PCA...</p>';

    try {
        const response = await fetch('/web/run-pca', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                n_components: components ? parseInt(components) : null,
                explained_variance: variance
            })
        });

        const data = await response.json();

        if (response.ok) {
            displayPCAResults(data.results);
        } else {
            resultsDiv.innerHTML = `<p class="error">Error: ${data.error}</p>`;
        }
    } catch (error) {
        resultsDiv.innerHTML = `<p class="error">Error: ${error.message}</p>`;
    }
}

function displayPCAResults(results) {
    const resultsDiv = document.getElementById('pca-results');
    const totalVariance = (results.cumulative_variance[results.cumulative_variance.length - 1] * 100).toFixed(2);

    let html = '<div class="success-message">‚úì PCA completata con successo</div>';

    // Explanation box
    html += `<div style="background: #f0f4ff; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #667eea;">
        <h4 style="margin: 0 0 10px 0; color: #667eea;">üìä Cos'√® la PCA?</h4>
        <p style="margin: 0; font-size: 14px; color: #333;">
            La <strong>Principal Component Analysis (PCA)</strong> riduce le dimensioni dei dati morfometrici
            mantenendo le informazioni pi√π importanti. Ogni "componente principale" (PC) cattura una direzione
            di massima variabilit√† nei dati.
        </p>
    </div>`;

    // Artifacts analyzed
    html += `<div style="background: #e8f5e9; padding: 12px; border-radius: 6px; margin: 10px 0;">
        <strong>üì¶ Artefatti analizzati:</strong> ${results.n_artifacts || results.artifact_ids?.length || 'N/A'}<br>
        <span style="font-size: 12px; color: #666;">
            ${results.artifact_ids ? results.artifact_ids.slice(0, 10).join(', ') : ''}
            ${results.artifact_ids && results.artifact_ids.length > 10 ? ` ... e altri ${results.artifact_ids.length - 10}` : ''}
        </span>
    </div>`;

    // ============ SELECTION REASONING - NEW ============
    if (results.selection) {
        html += `<div style="background: #fef3c7; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #f59e0b;">
            <h4 style="margin: 0 0 15px 0; color: #d97706;">üéØ Criteri di Selezione Componenti</h4>
            <div style="background: white; padding: 12px; border-radius: 6px; margin-bottom: 10px;">
                <strong>Riduzione dimensionale:</strong> ${results.selection.reduction_ratio || `${results.selection.total_features} ‚Üí ${results.selection.reduced_to}`}
            </div>
            <pre style="margin: 0; font-size: 13px; color: #333; white-space: pre-wrap; font-family: inherit; line-height: 1.6;">${results.selection.selection_reasoning || results.selection.criteria_explanation || ''}</pre>
        </div>`;
    }

    html += `<p><strong>Componenti selezionate:</strong> ${results.n_components} su ${results.total_possible_components || results.full_cumulative_variance?.length || '?'} possibili</p>`;
    html += `<p><strong>Varianza totale spiegata:</strong> ${totalVariance}%</p>`;

    // ============ ALL COMPONENTS TABLE - NEW ============
    if (results.all_components && results.all_components.length > 0) {
        html += `<div style="margin: 20px 0;">
            <h4>üìã Tabella Completa Componenti (tutte le PC possibili)</h4>
            <p style="font-size: 13px; color: #666; margin-bottom: 10px;">
                Questa tabella mostra TUTTE le componenti disponibili e spiega perch√© alcune sono state selezionate e altre escluse.
            </p>
            <div style="max-height: 400px; overflow-y: auto; border: 1px solid #e0e0e0; border-radius: 8px;">
                <table style="width: 100%; border-collapse: collapse; font-size: 13px;">
                    <thead style="background: #f8f9fa; position: sticky; top: 0;">
                        <tr>
                            <th style="padding: 10px; text-align: left; border-bottom: 2px solid #e0e0e0;">PC</th>
                            <th style="padding: 10px; text-align: right; border-bottom: 2px solid #e0e0e0;">Eigenvalue</th>
                            <th style="padding: 10px; text-align: right; border-bottom: 2px solid #e0e0e0;">Varianza %</th>
                            <th style="padding: 10px; text-align: right; border-bottom: 2px solid #e0e0e0;">Cumulativa %</th>
                            <th style="padding: 10px; text-align: center; border-bottom: 2px solid #e0e0e0;">Kaiser</th>
                            <th style="padding: 10px; text-align: left; border-bottom: 2px solid #e0e0e0;">Features principali</th>
                            <th style="padding: 10px; text-align: left; border-bottom: 2px solid #e0e0e0;">Decisione</th>
                        </tr>
                    </thead>
                    <tbody>`;

        results.all_components.forEach(comp => {
            const rowBg = comp.selected ? '#e8f5e9' : '#fff';
            const statusIcon = comp.selected ? '‚úÖ' : '‚ùå';
            const kaiserIcon = comp.passes_kaiser ? '‚úì' : '‚úó';
            const kaiserColor = comp.passes_kaiser ? '#10b981' : '#ef4444';
            const topFeatures = comp.top_features ? comp.top_features.map(f => f.name).slice(0, 2).join(', ') : '-';

            html += `<tr style="background: ${rowBg}; border-bottom: 1px solid #e0e0e0;">
                <td style="padding: 10px; font-weight: bold;">PC${comp.pc}</td>
                <td style="padding: 10px; text-align: right;">${comp.eigenvalue.toFixed(3)}</td>
                <td style="padding: 10px; text-align: right;">${comp.variance_percent.toFixed(2)}%</td>
                <td style="padding: 10px; text-align: right; font-weight: bold;">${comp.cumulative_percent.toFixed(2)}%</td>
                <td style="padding: 10px; text-align: center; color: ${kaiserColor}; font-weight: bold;">${kaiserIcon}</td>
                <td style="padding: 10px; font-size: 12px;">${topFeatures}</td>
                <td style="padding: 10px;">${statusIcon}</td>
            </tr>`;
        });

        html += `</tbody></table></div>
            <p style="font-size: 12px; color: #666; margin-top: 8px;">
                <strong>Legenda:</strong> Kaiser ‚úì = eigenvalue > 1 (varianza sopra la media)
            </p>
        </div>`;
    }

    // ============ DETAILED SELECTED COMPONENTS ============
    html += '<h4 style="margin-top: 25px;">üìê Dettaglio Componenti SELEZIONATE:</h4>';

    if (results.component_features) {
        results.component_features.forEach((comp, i) => {
            const pct = (comp.variance_explained * 100).toFixed(2);
            html += `<div style="background: white; border: 1px solid #e0e0e0; border-radius: 8px; padding: 15px; margin: 10px 0;">
                <h5 style="margin: 0 0 10px 0; color: #667eea;">
                    PC${comp.pc} - ${pct}% della varianza
                </h5>`;

            // Why selected - NEW
            if (comp.why_selected) {
                html += `<div style="background: #e8f5e9; padding: 10px; border-radius: 6px; margin-bottom: 10px; font-size: 13px;">
                    <strong>Motivazione:</strong> ${comp.why_selected}
                </div>`;
            }

            // Interpretation
            if (comp.interpretation) {
                html += `<div style="background: #f0f4ff; padding: 10px; border-radius: 6px; margin-bottom: 10px; font-size: 13px;">
                    <strong>Interpretazione:</strong> ${comp.interpretation}
                </div>`;
            }

            html += `<p style="margin: 0 0 10px 0; font-size: 13px; color: #666;">
                Features che influenzano maggiormente questa componente:
            </p>
            <ul style="margin: 0; padding-left: 20px;">`;

            comp.top_features.forEach(feat => {
                const direction = feat.loading > 0 ? '‚Üë' : '‚Üì';
                const color = feat.loading > 0 ? '#10b981' : '#ef4444';
                const dirText = feat.direction || (feat.loading > 0 ? 'positivo' : 'negativo');
                html += `<li style="margin: 5px 0;">
                    <strong>${feat.name}</strong>:
                    <span style="color: ${color};">${direction} ${dirText}</span>
                    (loading: ${(feat.loading * 100).toFixed(1)}%, importanza: ${(feat.importance * 100).toFixed(1)}%)
                </li>`;
            });

            html += `</ul></div>`;
        });
    }

    // Show excluded components summary
    if (results.all_components) {
        const excluded = results.all_components.filter(c => !c.selected);
        if (excluded.length > 0) {
            html += `<div style="background: #fef2f2; padding: 15px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #ef4444;">
                <h4 style="margin: 0 0 10px 0; color: #dc2626;">‚ùå Componenti ESCLUSE (${excluded.length})</h4>
                <p style="font-size: 13px; margin-bottom: 10px;">
                    Queste componenti sono state escluse perch√© il target di varianza (${(results.selection?.target_variance * 100) || 95}%)
                    √® gi√† stato raggiunto con le prime ${results.n_components} componenti.
                </p>
                <div style="max-height: 150px; overflow-y: auto;">`;

            excluded.slice(0, 10).forEach(comp => {
                html += `<div style="background: white; padding: 8px; border-radius: 4px; margin: 5px 0; font-size: 12px;">
                    <strong>PC${comp.pc}</strong>: ${comp.variance_percent.toFixed(2)}% varianza
                    <span style="color: #666;"> - ${comp.selection_reason || 'Varianza insufficiente'}</span>
                </div>`;
            });

            if (excluded.length > 10) {
                html += `<p style="font-size: 12px; color: #666; margin: 10px 0 0 0;">... e altre ${excluded.length - 10} componenti</p>`;
            }

            html += `</div></div>`;
        }
    }

    resultsDiv.innerHTML = html;

    // Plot PCA
    plotPCA(results);
}

async function runClustering() {
    const method = document.getElementById('cluster-method').value;

    const resultsDiv = document.getElementById('clustering-results');
    resultsDiv.innerHTML = '<p class="loading">Running clustering...</p>';

    let params = {method: method};

    if (method === 'hierarchical') {
        params.n_clusters = parseInt(document.getElementById('n-clusters').value);
        params.linkage = document.getElementById('linkage-method').value;
    } else {
        params.eps = parseFloat(document.getElementById('eps').value);
        params.min_samples = parseInt(document.getElementById('min-samples').value);
    }

    try {
        const response = await fetch('/web/run-clustering', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(params)
        });

        const data = await response.json();

        if (response.ok) {
            displayClusteringResults(data.results);
        } else {
            resultsDiv.innerHTML = `<p class="error">Error: ${data.error}</p>`;
        }
    } catch (error) {
        resultsDiv.innerHTML = `<p class="error">Error: ${error.message}</p>`;
    }
}

// Store clustering results globally for download
let lastClusteringResults = null;

function displayClusteringResults(results) {
    const resultsDiv = document.getElementById('clustering-results');
    const method = document.getElementById('cluster-method').value;
    lastClusteringResults = results; // Store for download

    let html = '<div class="success-message">‚úì Clustering completato con successo</div>';

    // Explanation box
    html += `<div style="background: #fff7ed; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #f59e0b;">
        <h4 style="margin: 0 0 10px 0; color: #d97706;">üî¨ Cos'√® il Clustering?</h4>
        <p style="margin: 0; font-size: 14px; color: #333;">
            Il <strong>Clustering</strong> raggruppa automaticamente gli artefatti in base alla loro
            similarit√† morfometrica. Artefatti nello stesso cluster condividono caratteristiche simili
            (dimensioni, proporzioni, forma).
        </p>
    </div>`;

    // ============ METHODOLOGY EXPLANATION - NEW ============
    if (results.clustering_explanation) {
        const expl = results.clustering_explanation;
        html += `<div style="background: #fef3c7; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #f59e0b;">
            <h4 style="margin: 0 0 15px 0; color: #d97706;">üéØ Metodologia e Criteri</h4>

            <div style="background: white; padding: 12px; border-radius: 6px; margin-bottom: 10px;">
                <strong>Metodo utilizzato:</strong> ${expl.method_used?.toUpperCase() || method}<br>
                <span style="font-size: 13px; color: #666;">${expl.method_explanation || ''}</span>
            </div>

            <div style="background: white; padding: 12px; border-radius: 6px; margin-bottom: 10px;">
                <strong>Numero cluster:</strong> ${expl.n_clusters_reason || `${results.n_clusters} cluster`}
            </div>

            ${expl.quality_interpretation ? `
            <div style="background: white; padding: 12px; border-radius: 6px; margin-bottom: 10px;">
                <strong>Qualit√† del clustering (Silhouette Score):</strong><br>
                <span style="font-size: 13px;">${expl.quality_interpretation}</span>
            </div>` : ''}

            <div style="font-size: 13px; color: #333; margin-top: 10px;">
                <strong>Procedura:</strong> ${expl.methodology || ''}
            </div>
        </div>`;
    }

    // Artifacts analyzed
    html += `<div style="background: #e8f5e9; padding: 12px; border-radius: 6px; margin: 10px 0;">
        <strong>üì¶ Artefatti analizzati:</strong> ${results.n_artifacts || 'N/A'}
        ${results.clustering_explanation?.features_used ? `<br><span style="font-size: 12px; color: #666;">Features utilizzate: ${results.clustering_explanation.features_used}</span>` : ''}
    </div>`;

    html += `<p><strong>Metodo:</strong> ${method === 'hierarchical' ? `Gerarchico (${results.method || 'Ward'})` : 'DBSCAN'}</p>`;
    html += `<p><strong>Cluster trovati:</strong> ${results.n_clusters}</p>`;

    if (results.noise && results.noise.length > 0) {
        html += `<p><strong>Punti rumore (outliers):</strong> ${results.noise.length}
            <span style="color: #666; font-size: 12px;">- artefatti atipici che non rientrano in nessun gruppo</span></p>`;
    }

    // Download button
    html += `<button onclick="downloadClusterList()" style="background: #10b981; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; margin: 10px 0;">
        üì• Scarica Lista Cluster (CSV)
    </button>`;

    // Interpretation
    const totalArtifacts = Object.values(results.clusters).reduce((sum, arr) => sum + arr.length, 0);

    html += `<div style="background: #f8f9fa; padding: 12px; border-radius: 6px; margin: 10px 0;">
        <strong>üîç Interpretazione archeologica:</strong><br>`;

    if (results.n_clusters === 1) {
        html += `Tutti gli artefatti appartengono a un <strong>unico gruppo omogeneo</strong>,
                 suggerendo una produzione standardizzata o una stessa tradizione artigianale.`;
    } else if (results.n_clusters <= 3) {
        html += `${results.n_clusters} gruppi distinti identificati. Questo potrebbe indicare
                 <strong>diverse tipologie</strong>, fasi cronologiche, o tradizioni produttive.`;
    } else {
        html += `${results.n_clusters} gruppi identificati, indicando una <strong>significativa variabilit√† morfologica</strong>.
                 Potrebbero rappresentare diverse botteghe, periodi, o funzioni.`;
    }
    html += `</div>`;

    html += '<h4>üìä Dettaglio Cluster:</h4>';

    const sortedClusters = Object.entries(results.clusters).sort((a, b) => b[1].length - a[1].length);
    const colors = ['#667eea', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#06b6d4', '#ec4899', '#84cc16'];

    for (const [clusterId, members] of sortedClusters) {
        const pct = ((members.length / totalArtifacts) * 100).toFixed(1);
        const color = colors[parseInt(clusterId) % colors.length];
        const stats = results.cluster_stats ? results.cluster_stats[clusterId] : null;

        html += `<div style="background: white; border: 1px solid #e0e0e0; border-radius: 8px; padding: 15px; margin: 10px 0; border-left: 4px solid ${color};">
            <h5 style="margin: 0 0 10px 0; color: ${color};">
                Cluster ${clusterId} - ${members.length} artefatti (${pct}%)
            </h5>`;

        // Cluster interpretation - NEW
        if (stats && stats.interpretation) {
            html += `<div style="background: #e8f5e9; padding: 10px; border-radius: 6px; margin-bottom: 10px; font-size: 13px;">
                <strong>üìù Interpretazione:</strong> ${stats.interpretation}
            </div>`;
        }

        // Distinguishing characteristics with explanation
        if (stats && stats.distinguishing_features) {
            html += `<div style="background: #f8f9fa; padding: 10px; border-radius: 6px; margin-bottom: 10px;">
                <strong>üéØ Caratteristiche distintive:</strong>
                <p style="font-size: 12px; color: #666; margin: 5px 0;">
                    Queste sono le features che distinguono questo cluster dagli altri (ordinate per importanza):
                </p>
                <ul style="margin: 5px 0 0 0; padding-left: 20px;">`;

            stats.distinguishing_features.forEach((feat, idx) => {
                const icon = feat.direction === 'alto' ? '‚Üë' : '‚Üì';
                const colorFeat = feat.direction === 'alto' ? '#10b981' : '#ef4444';
                const zScoreAbs = Math.abs(feat.z_score || 0).toFixed(2);
                html += `<li style="margin: 5px 0;">
                    <strong>${feat.name}</strong>:
                    <span style="color: ${colorFeat};">${icon} ${feat.direction}</span>
                    <br><span style="font-size: 11px; color: #666;">
                        Media cluster: <strong>${feat.cluster_mean.toFixed(2)}</strong> vs
                        Media generale: ${feat.overall_mean.toFixed(2)}
                        (z-score: ${zScoreAbs} = ${zScoreAbs > 2 ? 'molto significativo' : zScoreAbs > 1 ? 'significativo' : 'moderato'})
                    </span>
                </li>`;
            });

            html += `</ul></div>`;
        }

        // Why this cluster exists - NEW
        html += `<div style="background: #f0f4ff; padding: 10px; border-radius: 6px; margin-bottom: 10px; font-size: 12px;">
            <strong>‚ùì Perch√© questo cluster?</strong><br>
            Questi ${members.length} artefatti sono stati raggruppati insieme perch√© condividono
            ${stats?.distinguishing_features?.length > 0 ?
                `valori simili per ${stats.distinguishing_features.slice(0, 2).map(f => f.name).join(' e ')}.` :
                'caratteristiche morfometriche simili.'}
            La distanza morfometrica media tra questi artefatti √® minore rispetto agli artefatti di altri cluster.
        </div>`;

        // Member list
        html += `<div style="font-size: 12px; color: #666;">
            <strong>Membri:</strong><br>
            <div style="max-height: 100px; overflow-y: auto; background: #f5f5f5; padding: 8px; border-radius: 4px; margin-top: 5px;">
                ${members.join(', ')}
            </div>
        </div>
        </div>`;
    }

    resultsDiv.innerHTML = html;

    // Plot clusters
    plotClusters(results);
}

function downloadClusterList() {
    if (!lastClusteringResults) {
        alert('Esegui prima il clustering');
        return;
    }

    let csv = 'Artifact_ID,Cluster\n';
    for (const [clusterId, members] of Object.entries(lastClusteringResults.clusters)) {
        members.forEach(member => {
            csv += `${member},${clusterId}\n`;
        });
    }

    // Add characteristics summary
    csv += '\n\n--- CARATTERISTICHE CLUSTER ---\n';
    if (lastClusteringResults.cluster_stats) {
        for (const [clusterId, stats] of Object.entries(lastClusteringResults.cluster_stats)) {
            csv += `\nCluster ${clusterId} (${stats.n_members} artefatti):\n`;
            if (stats.distinguishing_features) {
                stats.distinguishing_features.forEach(feat => {
                    csv += `  - ${feat.name}: ${feat.direction} (media: ${feat.cluster_mean.toFixed(2)})\n`;
                });
            }
        }
    }

    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'cluster_analysis.csv';
    a.click();
    URL.revokeObjectURL(url);
}

function plotPCA(results) {
    const vizContainer = document.getElementById('viz-container');

    // Create scree plot
    const screePlot = {
        x: results.explained_variance_ratio.map((_, i) => `PC${i + 1}`),
        y: results.explained_variance_ratio.map(v => v * 100),
        type: 'bar',
        name: 'Variance Explained',
        marker: {color: '#4361ee'}
    };

    const layout = {
        title: 'PCA Scree Plot',
        xaxis: {title: 'Principal Component'},
        yaxis: {title: 'Variance Explained (%)'},
        height: 400
    };

    vizContainer.innerHTML = '<div id="scree-plot"></div>';
    Plotly.newPlot('scree-plot', [screePlot], layout);
}

function plotClusters(results) {
    const vizContainer = document.getElementById('viz-container');
    const colors = ['#667eea', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#06b6d4', '#ec4899', '#84cc16'];

    // Create container for multiple plots
    vizContainer.innerHTML = `
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
            <div id="scatter-plot-pca" style="border: 1px solid #e0e0e0; border-radius: 8px; padding: 10px;"></div>
            <div id="cluster-sizes-plot" style="border: 1px solid #e0e0e0; border-radius: 8px; padding: 10px;"></div>
        </div>
        <div id="box-plots-container" style="border: 1px solid #e0e0e0; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
            <h4 style="margin: 0 0 15px 0; color: #667eea;">üìä Distribuzione Features per Cluster (Limiti e Range)</h4>
            <div id="box-plots" style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;"></div>
        </div>
        <div style="background: #f0f4ff; padding: 15px; border-radius: 8px; border-left: 4px solid #667eea;">
            <h4 style="margin: 0 0 10px 0; color: #667eea;">üìñ Come leggere i grafici</h4>
            <ul style="margin: 0; font-size: 13px; color: #333; padding-left: 20px;">
                <li><strong>Scatter Plot (PCA):</strong> Ogni punto √® un artefatto. Punti vicini = artefatti simili. I colori indicano i cluster.</li>
                <li><strong>Box Plot:</strong> Mostra la distribuzione di ogni feature per cluster. La "scatola" contiene il 50% centrale dei dati. I "baffi" mostrano i limiti.</li>
                <li><strong>Limiti cluster:</strong> I rettangoli tratteggiati nel scatter plot indicano i confini approssimativi di ogni cluster.</li>
            </ul>
        </div>
    `;

    // 1. Scatter plot with PCA coordinates
    if (results.visualization_data && results.visualization_data.scatter_pca) {
        const vizData = results.visualization_data;
        const scatterTraces = [];

        // Group by cluster
        const clusterGroups = {};
        vizData.scatter_pca.forEach(point => {
            if (!clusterGroups[point.cluster]) {
                clusterGroups[point.cluster] = { x: [], y: [], ids: [] };
            }
            clusterGroups[point.cluster].x.push(point.x);
            clusterGroups[point.cluster].y.push(point.y);
            clusterGroups[point.cluster].ids.push(point.id);
        });

        // Create trace for each cluster
        Object.entries(clusterGroups).sort((a,b) => parseInt(a[0]) - parseInt(b[0])).forEach(([cluster, data], idx) => {
            scatterTraces.push({
                x: data.x,
                y: data.y,
                mode: 'markers',
                type: 'scatter',
                name: `Cluster ${cluster}`,
                text: data.ids,
                hovertemplate: '%{text}<br>PC1: %{x:.2f}<br>PC2: %{y:.2f}<extra>Cluster ' + cluster + '</extra>',
                marker: {
                    size: 10,
                    color: colors[parseInt(cluster) % colors.length],
                    line: { width: 1, color: 'white' }
                }
            });
        });

        // Add cluster boundaries as rectangles
        if (vizData.cluster_bounds) {
            Object.entries(vizData.cluster_bounds).forEach(([clusterName, bounds], idx) => {
                const clusterNum = clusterName.replace('Cluster ', '');
                scatterTraces.push({
                    x: [bounds.x_min, bounds.x_max, bounds.x_max, bounds.x_min, bounds.x_min],
                    y: [bounds.y_min, bounds.y_min, bounds.y_max, bounds.y_max, bounds.y_min],
                    mode: 'lines',
                    type: 'scatter',
                    name: `Limiti ${clusterName}`,
                    line: {
                        color: colors[parseInt(clusterNum) % colors.length],
                        dash: 'dash',
                        width: 2
                    },
                    fill: 'toself',
                    fillcolor: colors[parseInt(clusterNum) % colors.length] + '15',
                    showlegend: false
                });
            });
        }

        const pcaVariance = vizData.pca_explained_variance || [0.5, 0.3];
        Plotly.newPlot('scatter-plot-pca', scatterTraces, {
            title: 'Distribuzione Cluster (PCA)',
            xaxis: { title: `PC1 (${(pcaVariance[0] * 100).toFixed(1)}% varianza)`, zeroline: false },
            yaxis: { title: `PC2 (${(pcaVariance[1] * 100).toFixed(1)}% varianza)`, zeroline: false },
            height: 400,
            showlegend: true,
            legend: { x: 1, xanchor: 'right', y: 1 }
        });
    }

    // 2. Cluster sizes bar plot
    const clusterSizes = Object.entries(results.clusters).map(([id, members]) => ({
        cluster: id,
        size: members.length
    })).sort((a, b) => parseInt(a.cluster) - parseInt(b.cluster));

    Plotly.newPlot('cluster-sizes-plot', [{
        x: clusterSizes.map(c => `Cluster ${c.cluster}`),
        y: clusterSizes.map(c => c.size),
        type: 'bar',
        marker: {
            color: clusterSizes.map(c => colors[parseInt(c.cluster) % colors.length])
        },
        text: clusterSizes.map(c => c.size),
        textposition: 'auto'
    }], {
        title: 'Dimensione Cluster',
        xaxis: { title: 'Cluster' },
        yaxis: { title: 'Numero Artefatti' },
        height: 400
    });

    // 3. Box plots for feature distributions per cluster
    if (results.visualization_data && results.visualization_data.box_plots) {
        const boxPlotContainer = document.getElementById('box-plots');
        const boxPlotData = results.visualization_data.box_plots;
        const topFeatures = results.visualization_data.top_features || [];

        let boxHtml = '';
        Object.entries(boxPlotData).forEach(([featureName, clusterData], idx) => {
            const plotId = `box-plot-${idx}`;
            const isTopFeature = topFeatures.includes(featureName);

            boxHtml += `<div id="${plotId}" style="min-height: 300px; ${isTopFeature ? 'border: 2px solid #667eea; border-radius: 8px;' : ''}"></div>`;
        });
        boxPlotContainer.innerHTML = boxHtml;

        // Create each box plot
        Object.entries(boxPlotData).forEach(([featureName, clusterData], idx) => {
            const plotId = `box-plot-${idx}`;
            const traces = [];

            Object.entries(clusterData).sort((a,b) => parseInt(a[0].replace('Cluster ', '')) - parseInt(b[0].replace('Cluster ', ''))).forEach(([clusterName, stats], cIdx) => {
                traces.push({
                    y: stats.values,
                    type: 'box',
                    name: clusterName,
                    boxpoints: 'all',
                    jitter: 0.3,
                    pointpos: -1.8,
                    marker: {
                        color: colors[cIdx % colors.length],
                        size: 4
                    },
                    line: { color: colors[cIdx % colors.length] }
                });
            });

            Plotly.newPlot(plotId, traces, {
                title: {
                    text: featureName + (topFeatures.includes(featureName) ? ' ‚≠ê' : ''),
                    font: { size: 14 }
                },
                yaxis: { title: 'Valore (standardizzato)', zeroline: true },
                showlegend: idx === 0,
                height: 300,
                margin: { t: 50, b: 50 }
            });
        });

        // Add legend explanation
        boxPlotContainer.innerHTML += `
            <div style="grid-column: 1 / -1; background: #fff7ed; padding: 10px; border-radius: 6px; margin-top: 10px; font-size: 12px;">
                <strong>‚≠ê Features pi√π distintive:</strong> ${topFeatures.join(', ')}<br>
                <span style="color: #666;">Queste features mostrano la maggiore differenza tra i cluster e sono pi√π utili per distinguere i gruppi.</span>
            </div>
        `;
    }
}
</script>
{% endblock %}
