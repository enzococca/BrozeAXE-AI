{% extends "base.html" %}

{% block title %}Morphometric Analysis - Archaeological Classifier{% endblock %}

{% block extra_head %}
<script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
{% endblock %}

{% block content %}
<div class="container">
    <div class="page-header">
        <h1>Morphometric Analysis</h1>
        <p class="subtitle">PCA, clustering, and similarity analysis</p>
    </div>

    <div class="analysis-container">
        <div class="card">
            <h2>Principal Component Analysis (PCA)</h2>
            <div class="form-group">
                <label>Number of Components (leave empty for auto)</label>
                <input type="number" id="pca-components" class="form-input" placeholder="Auto">
            </div>
            <div class="form-group">
                <label>Explained Variance Threshold</label>
                <input type="number" id="pca-variance" class="form-input" value="0.95" step="0.05" min="0.5" max="1.0">
            </div>
            <button onclick="runPCA()" class="btn btn-primary">Run PCA</button>
            <div id="pca-results" class="results-container"></div>
        </div>

        <div class="card">
            <h2>Clustering Analysis</h2>
            <div class="form-group">
                <label>Method</label>
                <select id="cluster-method" class="form-input" onchange="updateClusteringOptions()">
                    <option value="hierarchical">Hierarchical</option>
                    <option value="dbscan">DBSCAN</option>
                </select>
            </div>

            <div id="hierarchical-options">
                <div class="form-group">
                    <label>Number of Clusters</label>
                    <input type="number" id="n-clusters" class="form-input" value="5" min="2">
                </div>
                <div class="form-group">
                    <label>Linkage Method</label>
                    <select id="linkage-method" class="form-input">
                        <option value="ward">Ward</option>
                        <option value="complete">Complete</option>
                        <option value="average">Average</option>
                    </select>
                </div>
            </div>

            <div id="dbscan-options" style="display: none;">
                <div class="form-group">
                    <label>Epsilon (eps)</label>
                    <input type="number" id="eps" class="form-input" value="0.5" step="0.1">
                </div>
                <div class="form-group">
                    <label>Min Samples</label>
                    <input type="number" id="min-samples" class="form-input" value="3" min="2">
                </div>
            </div>

            <button onclick="runClustering()" class="btn btn-primary">Run Clustering</button>
            <div id="clustering-results" class="results-container"></div>
        </div>

        <div class="card full-width">
            <h2>Visualization</h2>
            <div id="viz-container" class="viz-container">
                <p class="text-muted">Run analysis to see visualizations</p>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
function updateClusteringOptions() {
    const method = document.getElementById('cluster-method').value;
    document.getElementById('hierarchical-options').style.display =
        method === 'hierarchical' ? 'block' : 'none';
    document.getElementById('dbscan-options').style.display =
        method === 'dbscan' ? 'block' : 'none';
}

async function runPCA() {
    const components = document.getElementById('pca-components').value;
    const variance = parseFloat(document.getElementById('pca-variance').value);

    const resultsDiv = document.getElementById('pca-results');
    resultsDiv.innerHTML = '<p class="loading">Running PCA...</p>';

    try {
        const response = await fetch('/web/run-pca', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                n_components: components ? parseInt(components) : null,
                explained_variance: variance
            })
        });

        const data = await response.json();

        if (response.ok) {
            displayPCAResults(data.results);
        } else {
            resultsDiv.innerHTML = `<p class="error">Error: ${data.error}</p>`;
        }
    } catch (error) {
        resultsDiv.innerHTML = `<p class="error">Error: ${error.message}</p>`;
    }
}

function displayPCAResults(results) {
    const resultsDiv = document.getElementById('pca-results');
    const totalVariance = (results.cumulative_variance[results.cumulative_variance.length - 1] * 100).toFixed(2);

    let html = '<div class="success-message">‚úì PCA completata con successo</div>';

    // Explanation box
    html += `<div style="background: #f0f4ff; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #667eea;">
        <h4 style="margin: 0 0 10px 0; color: #667eea;">üìä Cos'√® la PCA?</h4>
        <p style="margin: 0; font-size: 14px; color: #333;">
            La <strong>Principal Component Analysis (PCA)</strong> riduce le dimensioni dei dati morfometrici
            mantenendo le informazioni pi√π importanti. Ogni "componente principale" (PC) cattura una direzione
            di massima variabilit√† nei dati.
        </p>
    </div>`;

    html += `<p><strong>Componenti estratte:</strong> ${results.n_components}</p>`;
    html += `<p><strong>Varianza totale spiegata:</strong> ${totalVariance}%</p>`;

    // Interpretation
    html += `<div style="background: #f8f9fa; padding: 12px; border-radius: 6px; margin: 10px 0;">
        <strong>üîç Interpretazione:</strong><br>`;

    if (parseFloat(totalVariance) >= 90) {
        html += `<span style="color: #10b981;">Eccellente!</span> Le ${results.n_components} componenti catturano il ${totalVariance}% della variabilit√†. `;
    } else if (parseFloat(totalVariance) >= 75) {
        html += `<span style="color: #f59e0b;">Buono.</span> Le componenti catturano il ${totalVariance}% della variabilit√†. `;
    } else {
        html += `<span style="color: #ef4444;">Attenzione:</span> Solo ${totalVariance}% della variabilit√† √® catturata. `;
    }

    html += `La <strong>PC1</strong> (${(results.explained_variance_ratio[0] * 100).toFixed(1)}%) rappresenta la direzione di massima variazione morfologica tra gli artefatti.`;
    html += `</div>`;

    html += '<h4>Varianza per Componente:</h4><ul>';
    results.explained_variance_ratio.forEach((v, i) => {
        const pct = (v * 100).toFixed(2);
        const bar = '‚ñà'.repeat(Math.round(v * 20));
        html += `<li><strong>PC${i + 1}:</strong> ${pct}% <span style="color: #667eea; font-family: monospace;">${bar}</span></li>`;
    });
    html += '</ul>';

    resultsDiv.innerHTML = html;

    // Plot PCA
    plotPCA(results);
}

async function runClustering() {
    const method = document.getElementById('cluster-method').value;

    const resultsDiv = document.getElementById('clustering-results');
    resultsDiv.innerHTML = '<p class="loading">Running clustering...</p>';

    let params = {method: method};

    if (method === 'hierarchical') {
        params.n_clusters = parseInt(document.getElementById('n-clusters').value);
        params.linkage = document.getElementById('linkage-method').value;
    } else {
        params.eps = parseFloat(document.getElementById('eps').value);
        params.min_samples = parseInt(document.getElementById('min-samples').value);
    }

    try {
        const response = await fetch('/web/run-clustering', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(params)
        });

        const data = await response.json();

        if (response.ok) {
            displayClusteringResults(data.results);
        } else {
            resultsDiv.innerHTML = `<p class="error">Error: ${data.error}</p>`;
        }
    } catch (error) {
        resultsDiv.innerHTML = `<p class="error">Error: ${error.message}</p>`;
    }
}

function displayClusteringResults(results) {
    const resultsDiv = document.getElementById('clustering-results');
    const method = document.getElementById('cluster-method').value;

    let html = '<div class="success-message">‚úì Clustering completato con successo</div>';

    // Explanation box
    html += `<div style="background: #fff7ed; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #f59e0b;">
        <h4 style="margin: 0 0 10px 0; color: #d97706;">üî¨ Cos'√® il Clustering?</h4>
        <p style="margin: 0; font-size: 14px; color: #333;">
            Il <strong>Clustering</strong> raggruppa automaticamente gli artefatti in base alla loro
            similarit√† morfometrica. Artefatti nello stesso cluster condividono caratteristiche simili
            (dimensioni, proporzioni, forma).
        </p>
    </div>`;

    html += `<p><strong>Metodo:</strong> ${method === 'hierarchical' ? 'Gerarchico (Ward)' : 'DBSCAN'}</p>`;
    html += `<p><strong>Cluster trovati:</strong> ${results.n_clusters}</p>`;

    if (results.noise && results.noise.length > 0) {
        html += `<p><strong>Punti rumore (outliers):</strong> ${results.noise.length}
            <span style="color: #666; font-size: 12px;">- artefatti atipici che non rientrano in nessun gruppo</span></p>`;
    }

    // Interpretation
    html += `<div style="background: #f8f9fa; padding: 12px; border-radius: 6px; margin: 10px 0;">
        <strong>üîç Interpretazione archeologica:</strong><br>`;

    const totalArtifacts = Object.values(results.clusters).reduce((sum, arr) => sum + arr.length, 0);

    if (results.n_clusters === 1) {
        html += `Tutti gli artefatti appartengono a un <strong>unico gruppo omogeneo</strong>,
                 suggerendo una produzione standardizzata o una stessa tradizione artigianale.`;
    } else if (results.n_clusters <= 3) {
        html += `${results.n_clusters} gruppi distinti identificati. Questo potrebbe indicare
                 <strong>diverse tipologie</strong>, fasi cronologiche, o tradizioni produttive.`;
    } else {
        html += `${results.n_clusters} gruppi identificati, indicando una <strong>significativa variabilit√† morfologica</strong>.
                 Potrebbero rappresentare diverse botteghe, periodi, o funzioni.`;
    }
    html += `</div>`;

    html += '<h4>Distribuzione dei Cluster:</h4>';
    html += '<div style="display: grid; gap: 10px;">';

    const sortedClusters = Object.entries(results.clusters).sort((a, b) => b[1].length - a[1].length);

    for (const [clusterId, members] of sortedClusters) {
        const pct = ((members.length / totalArtifacts) * 100).toFixed(1);
        const colors = ['#667eea', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#06b6d4', '#ec4899', '#84cc16'];
        const color = colors[parseInt(clusterId) % colors.length];

        html += `<div style="background: white; padding: 10px; border-radius: 6px; border-left: 4px solid ${color};">
            <strong>Cluster ${clusterId}</strong>: ${members.length} artefatti (${pct}%)
            <div style="font-size: 12px; color: #666; margin-top: 5px;">
                ${members.slice(0, 5).join(', ')}${members.length > 5 ? ` ... e altri ${members.length - 5}` : ''}
            </div>
        </div>`;
    }
    html += '</div>';

    resultsDiv.innerHTML = html;

    // Plot clusters
    plotClusters(results);
}

function plotPCA(results) {
    const vizContainer = document.getElementById('viz-container');

    // Create scree plot
    const screePlot = {
        x: results.explained_variance_ratio.map((_, i) => `PC${i + 1}`),
        y: results.explained_variance_ratio.map(v => v * 100),
        type: 'bar',
        name: 'Variance Explained',
        marker: {color: '#4361ee'}
    };

    const layout = {
        title: 'PCA Scree Plot',
        xaxis: {title: 'Principal Component'},
        yaxis: {title: 'Variance Explained (%)'},
        height: 400
    };

    vizContainer.innerHTML = '<div id="scree-plot"></div>';
    Plotly.newPlot('scree-plot', [screePlot], layout);
}

function plotClusters(results) {
    // Placeholder - would need actual PCA coordinates for proper 2D plot
    const vizContainer = document.getElementById('viz-container');

    const clusterSizes = Object.entries(results.clusters).map(([id, members]) => ({
        cluster: id,
        size: members.length
    }));

    const barPlot = {
        x: clusterSizes.map(c => `Cluster ${c.cluster}`),
        y: clusterSizes.map(c => c.size),
        type: 'bar',
        marker: {color: '#4361ee'}
    };

    const layout = {
        title: 'Cluster Sizes',
        xaxis: {title: 'Cluster'},
        yaxis: {title: 'Number of Artifacts'},
        height: 400
    };

    vizContainer.innerHTML = '<div id="cluster-plot"></div>';
    Plotly.newPlot('cluster-plot', [barPlot], layout);
}
</script>
{% endblock %}
