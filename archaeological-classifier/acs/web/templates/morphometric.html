{% extends "base.html" %}

{% block title %}Morphometric Analysis - Archaeological Classifier{% endblock %}

{% block extra_head %}
<script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
{% endblock %}

{% block content %}
<div class="container">
    <div class="page-header">
        <h1>Morphometric Analysis</h1>
        <p class="subtitle">PCA, clustering, and similarity analysis</p>
    </div>

    <div class="analysis-container">
        <div class="card">
            <h2>Principal Component Analysis (PCA)</h2>
            <div class="form-group">
                <label>Number of Components (leave empty for auto)</label>
                <input type="number" id="pca-components" class="form-input" placeholder="Auto">
            </div>
            <div class="form-group">
                <label>Explained Variance Threshold</label>
                <input type="number" id="pca-variance" class="form-input" value="0.95" step="0.05" min="0.5" max="1.0">
            </div>
            <button onclick="runPCA()" class="btn btn-primary">Run PCA</button>
            <div id="pca-results" class="results-container"></div>
        </div>

        <div class="card">
            <h2>Clustering Analysis</h2>
            <div class="form-group">
                <label>Method</label>
                <select id="cluster-method" class="form-input" onchange="updateClusteringOptions()">
                    <option value="hierarchical">Hierarchical</option>
                    <option value="dbscan">DBSCAN</option>
                </select>
            </div>

            <div id="hierarchical-options">
                <div class="form-group">
                    <label>Number of Clusters</label>
                    <input type="number" id="n-clusters" class="form-input" value="5" min="2">
                </div>
                <div class="form-group">
                    <label>Linkage Method</label>
                    <select id="linkage-method" class="form-input">
                        <option value="ward">Ward</option>
                        <option value="complete">Complete</option>
                        <option value="average">Average</option>
                    </select>
                </div>
            </div>

            <div id="dbscan-options" style="display: none;">
                <div class="form-group">
                    <label>Epsilon (eps)</label>
                    <input type="number" id="eps" class="form-input" value="0.5" step="0.1">
                </div>
                <div class="form-group">
                    <label>Min Samples</label>
                    <input type="number" id="min-samples" class="form-input" value="3" min="2">
                </div>
            </div>

            <button onclick="runClustering()" class="btn btn-primary">Run Clustering</button>
            <div id="clustering-results" class="results-container"></div>
        </div>

        <div class="card full-width">
            <h2>Visualization</h2>
            <div id="viz-container" class="viz-container">
                <p class="text-muted">Run analysis to see visualizations</p>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
function updateClusteringOptions() {
    const method = document.getElementById('cluster-method').value;
    document.getElementById('hierarchical-options').style.display =
        method === 'hierarchical' ? 'block' : 'none';
    document.getElementById('dbscan-options').style.display =
        method === 'dbscan' ? 'block' : 'none';
}

async function runPCA() {
    const components = document.getElementById('pca-components').value;
    const variance = parseFloat(document.getElementById('pca-variance').value);

    const resultsDiv = document.getElementById('pca-results');
    resultsDiv.innerHTML = '<p class="loading">Running PCA...</p>';

    try {
        const response = await fetch('/web/run-pca', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                n_components: components ? parseInt(components) : null,
                explained_variance: variance
            })
        });

        const data = await response.json();

        if (response.ok) {
            displayPCAResults(data.results);
        } else {
            resultsDiv.innerHTML = `<p class="error">Error: ${data.error}</p>`;
        }
    } catch (error) {
        resultsDiv.innerHTML = `<p class="error">Error: ${error.message}</p>`;
    }
}

function displayPCAResults(results) {
    const resultsDiv = document.getElementById('pca-results');
    const totalVariance = (results.cumulative_variance[results.cumulative_variance.length - 1] * 100).toFixed(2);

    let html = '<div class="success-message">‚úì PCA completata con successo</div>';

    // Explanation box
    html += `<div style="background: #f0f4ff; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #667eea;">
        <h4 style="margin: 0 0 10px 0; color: #667eea;">üìä Cos'√® la PCA?</h4>
        <p style="margin: 0; font-size: 14px; color: #333;">
            La <strong>Principal Component Analysis (PCA)</strong> riduce le dimensioni dei dati morfometrici
            mantenendo le informazioni pi√π importanti. Ogni "componente principale" (PC) cattura una direzione
            di massima variabilit√† nei dati.
        </p>
    </div>`;

    // Artifacts analyzed
    html += `<div style="background: #e8f5e9; padding: 12px; border-radius: 6px; margin: 10px 0;">
        <strong>üì¶ Artefatti analizzati:</strong> ${results.n_artifacts || results.artifact_ids?.length || 'N/A'}<br>
        <span style="font-size: 12px; color: #666;">
            ${results.artifact_ids ? results.artifact_ids.slice(0, 10).join(', ') : ''}
            ${results.artifact_ids && results.artifact_ids.length > 10 ? ` ... e altri ${results.artifact_ids.length - 10}` : ''}
        </span>
    </div>`;

    html += `<p><strong>Componenti estratte:</strong> ${results.n_components}</p>`;
    html += `<p><strong>Varianza totale spiegata:</strong> ${totalVariance}%</p>`;

    // Interpretation
    html += `<div style="background: #f8f9fa; padding: 12px; border-radius: 6px; margin: 10px 0;">
        <strong>üîç Interpretazione:</strong><br>`;

    if (parseFloat(totalVariance) >= 90) {
        html += `<span style="color: #10b981;">Eccellente!</span> Le ${results.n_components} componenti catturano il ${totalVariance}% della variabilit√†. `;
    } else if (parseFloat(totalVariance) >= 75) {
        html += `<span style="color: #f59e0b;">Buono.</span> Le componenti catturano il ${totalVariance}% della variabilit√†. `;
    } else {
        html += `<span style="color: #ef4444;">Attenzione:</span> Solo ${totalVariance}% della variabilit√† √® catturata. `;
    }
    html += `</div>`;

    // Detailed component analysis
    html += '<h4>üìê Dettaglio Componenti Principali:</h4>';

    if (results.component_features) {
        results.component_features.forEach((comp, i) => {
            const pct = (comp.variance_explained * 100).toFixed(2);
            html += `<div style="background: white; border: 1px solid #e0e0e0; border-radius: 8px; padding: 15px; margin: 10px 0;">
                <h5 style="margin: 0 0 10px 0; color: #667eea;">
                    PC${comp.pc} - ${pct}% della varianza
                </h5>
                <p style="margin: 0 0 10px 0; font-size: 13px; color: #666;">
                    Questa componente √® principalmente influenzata da:
                </p>
                <ul style="margin: 0; padding-left: 20px;">`;

            comp.top_features.forEach(feat => {
                const direction = feat.loading > 0 ? '‚Üë' : '‚Üì';
                const color = feat.loading > 0 ? '#10b981' : '#ef4444';
                html += `<li style="margin: 5px 0;">
                    <strong>${feat.name}</strong>: ${direction}
                    <span style="color: ${color};">${(feat.loading * 100).toFixed(1)}%</span>
                    <span style="font-size: 11px; color: #999;">(importanza: ${(feat.importance * 100).toFixed(1)}%)</span>
                </li>`;
            });

            html += `</ul>
                <p style="margin: 10px 0 0 0; font-size: 12px; color: #718096; font-style: italic;">
                    ${i === 0 ? 'PC1 cattura la direzione di massima variazione morfologica - gli artefatti con valori PC1 simili hanno forme simili.' :
                      i === 1 ? 'PC2 cattura la seconda direzione di variazione, ortogonale a PC1.' :
                      `PC${comp.pc} cattura variazioni residue indipendenti dalle componenti precedenti.`}
                </p>
            </div>`;
        });
    } else {
        // Fallback to simple display
        html += '<ul>';
        results.explained_variance_ratio.forEach((v, i) => {
            const pct = (v * 100).toFixed(2);
            const bar = '‚ñà'.repeat(Math.round(v * 20));
            html += `<li><strong>PC${i + 1}:</strong> ${pct}% <span style="color: #667eea; font-family: monospace;">${bar}</span></li>`;
        });
        html += '</ul>';
    }

    resultsDiv.innerHTML = html;

    // Plot PCA
    plotPCA(results);
}

async function runClustering() {
    const method = document.getElementById('cluster-method').value;

    const resultsDiv = document.getElementById('clustering-results');
    resultsDiv.innerHTML = '<p class="loading">Running clustering...</p>';

    let params = {method: method};

    if (method === 'hierarchical') {
        params.n_clusters = parseInt(document.getElementById('n-clusters').value);
        params.linkage = document.getElementById('linkage-method').value;
    } else {
        params.eps = parseFloat(document.getElementById('eps').value);
        params.min_samples = parseInt(document.getElementById('min-samples').value);
    }

    try {
        const response = await fetch('/web/run-clustering', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(params)
        });

        const data = await response.json();

        if (response.ok) {
            displayClusteringResults(data.results);
        } else {
            resultsDiv.innerHTML = `<p class="error">Error: ${data.error}</p>`;
        }
    } catch (error) {
        resultsDiv.innerHTML = `<p class="error">Error: ${error.message}</p>`;
    }
}

// Store clustering results globally for download
let lastClusteringResults = null;

function displayClusteringResults(results) {
    const resultsDiv = document.getElementById('clustering-results');
    const method = document.getElementById('cluster-method').value;
    lastClusteringResults = results; // Store for download

    let html = '<div class="success-message">‚úì Clustering completato con successo</div>';

    // Explanation box
    html += `<div style="background: #fff7ed; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #f59e0b;">
        <h4 style="margin: 0 0 10px 0; color: #d97706;">üî¨ Cos'√® il Clustering?</h4>
        <p style="margin: 0; font-size: 14px; color: #333;">
            Il <strong>Clustering</strong> raggruppa automaticamente gli artefatti in base alla loro
            similarit√† morfometrica. Artefatti nello stesso cluster condividono caratteristiche simili
            (dimensioni, proporzioni, forma).
        </p>
    </div>`;

    // Artifacts analyzed
    html += `<div style="background: #e8f5e9; padding: 12px; border-radius: 6px; margin: 10px 0;">
        <strong>üì¶ Artefatti analizzati:</strong> ${results.n_artifacts || 'N/A'}
    </div>`;

    html += `<p><strong>Metodo:</strong> ${method === 'hierarchical' ? 'Gerarchico (Ward)' : 'DBSCAN'}</p>`;
    html += `<p><strong>Cluster trovati:</strong> ${results.n_clusters}</p>`;

    if (results.noise && results.noise.length > 0) {
        html += `<p><strong>Punti rumore (outliers):</strong> ${results.noise.length}
            <span style="color: #666; font-size: 12px;">- artefatti atipici che non rientrano in nessun gruppo</span></p>`;
    }

    // Download button
    html += `<button onclick="downloadClusterList()" style="background: #10b981; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; margin: 10px 0;">
        üì• Scarica Lista Cluster (CSV)
    </button>`;

    // Interpretation
    const totalArtifacts = Object.values(results.clusters).reduce((sum, arr) => sum + arr.length, 0);

    html += `<div style="background: #f8f9fa; padding: 12px; border-radius: 6px; margin: 10px 0;">
        <strong>üîç Interpretazione archeologica:</strong><br>`;

    if (results.n_clusters === 1) {
        html += `Tutti gli artefatti appartengono a un <strong>unico gruppo omogeneo</strong>,
                 suggerendo una produzione standardizzata o una stessa tradizione artigianale.`;
    } else if (results.n_clusters <= 3) {
        html += `${results.n_clusters} gruppi distinti identificati. Questo potrebbe indicare
                 <strong>diverse tipologie</strong>, fasi cronologiche, o tradizioni produttive.`;
    } else {
        html += `${results.n_clusters} gruppi identificati, indicando una <strong>significativa variabilit√† morfologica</strong>.
                 Potrebbero rappresentare diverse botteghe, periodi, o funzioni.`;
    }
    html += `</div>`;

    html += '<h4>üìä Dettaglio Cluster:</h4>';

    const sortedClusters = Object.entries(results.clusters).sort((a, b) => b[1].length - a[1].length);
    const colors = ['#667eea', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#06b6d4', '#ec4899', '#84cc16'];

    for (const [clusterId, members] of sortedClusters) {
        const pct = ((members.length / totalArtifacts) * 100).toFixed(1);
        const color = colors[parseInt(clusterId) % colors.length];
        const stats = results.cluster_stats ? results.cluster_stats[clusterId] : null;

        html += `<div style="background: white; border: 1px solid #e0e0e0; border-radius: 8px; padding: 15px; margin: 10px 0; border-left: 4px solid ${color};">
            <h5 style="margin: 0 0 10px 0; color: ${color};">
                Cluster ${clusterId} - ${members.length} artefatti (${pct}%)
            </h5>`;

        // Distinguishing characteristics
        if (stats && stats.distinguishing_features) {
            html += `<div style="background: #f8f9fa; padding: 10px; border-radius: 6px; margin-bottom: 10px;">
                <strong>üéØ Caratteristiche distintive:</strong>
                <ul style="margin: 5px 0 0 0; padding-left: 20px;">`;

            stats.distinguishing_features.forEach(feat => {
                const icon = feat.direction === 'alto' ? '‚Üë' : '‚Üì';
                const colorFeat = feat.direction === 'alto' ? '#10b981' : '#ef4444';
                html += `<li style="margin: 3px 0;">
                    <strong>${feat.name}</strong>:
                    <span style="color: ${colorFeat};">${icon} ${feat.direction}</span>
                    (media cluster: ${feat.cluster_mean.toFixed(2)} vs media generale: ${feat.overall_mean.toFixed(2)})
                </li>`;
            });

            html += `</ul></div>`;
        }

        // Member list
        html += `<div style="font-size: 12px; color: #666;">
            <strong>Membri:</strong><br>
            <div style="max-height: 100px; overflow-y: auto; background: #f5f5f5; padding: 8px; border-radius: 4px; margin-top: 5px;">
                ${members.join(', ')}
            </div>
        </div>
        </div>`;
    }

    resultsDiv.innerHTML = html;

    // Plot clusters
    plotClusters(results);
}

function downloadClusterList() {
    if (!lastClusteringResults) {
        alert('Esegui prima il clustering');
        return;
    }

    let csv = 'Artifact_ID,Cluster\n';
    for (const [clusterId, members] of Object.entries(lastClusteringResults.clusters)) {
        members.forEach(member => {
            csv += `${member},${clusterId}\n`;
        });
    }

    // Add characteristics summary
    csv += '\n\n--- CARATTERISTICHE CLUSTER ---\n';
    if (lastClusteringResults.cluster_stats) {
        for (const [clusterId, stats] of Object.entries(lastClusteringResults.cluster_stats)) {
            csv += `\nCluster ${clusterId} (${stats.n_members} artefatti):\n`;
            if (stats.distinguishing_features) {
                stats.distinguishing_features.forEach(feat => {
                    csv += `  - ${feat.name}: ${feat.direction} (media: ${feat.cluster_mean.toFixed(2)})\n`;
                });
            }
        }
    }

    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'cluster_analysis.csv';
    a.click();
    URL.revokeObjectURL(url);
}

function plotPCA(results) {
    const vizContainer = document.getElementById('viz-container');

    // Create scree plot
    const screePlot = {
        x: results.explained_variance_ratio.map((_, i) => `PC${i + 1}`),
        y: results.explained_variance_ratio.map(v => v * 100),
        type: 'bar',
        name: 'Variance Explained',
        marker: {color: '#4361ee'}
    };

    const layout = {
        title: 'PCA Scree Plot',
        xaxis: {title: 'Principal Component'},
        yaxis: {title: 'Variance Explained (%)'},
        height: 400
    };

    vizContainer.innerHTML = '<div id="scree-plot"></div>';
    Plotly.newPlot('scree-plot', [screePlot], layout);
}

function plotClusters(results) {
    // Placeholder - would need actual PCA coordinates for proper 2D plot
    const vizContainer = document.getElementById('viz-container');

    const clusterSizes = Object.entries(results.clusters).map(([id, members]) => ({
        cluster: id,
        size: members.length
    }));

    const barPlot = {
        x: clusterSizes.map(c => `Cluster ${c.cluster}`),
        y: clusterSizes.map(c => c.size),
        type: 'bar',
        marker: {color: '#4361ee'}
    };

    const layout = {
        title: 'Cluster Sizes',
        xaxis: {title: 'Cluster'},
        yaxis: {title: 'Number of Artifacts'},
        height: 400
    };

    vizContainer.innerHTML = '<div id="cluster-plot"></div>';
    Plotly.newPlot('cluster-plot', [barPlot], layout);
}
</script>
{% endblock %}
