{% extends "base.html" %}

{% block title %}3D Viewer - Archaeological Classifier{% endblock %}

{% block content %}
<div class="page-header">
    <h1>üé® 3D Artifact Viewer</h1>
    <p>Interactive 3D visualization with texture support</p>
</div>

<div class="viewer-container">
    <!-- Viewer Controls -->
    <div class="viewer-controls card">
        <h3>Controls</h3>
        <div class="control-group">
            <label for="artifact-select">Select Artifact:</label>
            <select id="artifact-select" class="form-control">
                <option value="">-- Select an artifact --</option>
                {% for artifact_id in artifacts %}
                <option value="{{ artifact_id }}">{{ artifact_id }}</option>
                {% endfor %}
            </select>
        </div>

        <div class="control-group">
            <button id="reset-camera" class="btn btn-secondary">Reset Camera</button>
            <button id="wireframe-toggle" class="btn btn-secondary">Toggle Wireframe</button>
            <button id="fullscreen-btn" class="btn btn-secondary">Fullscreen</button>
        </div>

        <div class="control-group">
            <h4>Display Options</h4>
            <label>
                <input type="checkbox" id="show-axes" checked> Show Axes
            </label>
            <label>
                <input type="checkbox" id="show-grid" checked> Show Grid
            </label>
            <label>
                <input type="checkbox" id="auto-rotate"> Auto Rotate
            </label>
        </div>

        <!-- Advanced Camera Controls -->
        <div class="control-group">
            <h4>üì∑ Camera Controls</h4>

            <label style="font-size: 12px; color: #666; margin-bottom: 5px; display: block;">Preset Views:</label>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-bottom: 10px;">
                <button id="view-top" class="btn btn-sm btn-outline">Top</button>
                <button id="view-front" class="btn btn-sm btn-outline">Front</button>
                <button id="view-side" class="btn btn-sm btn-outline">Side</button>
                <button id="view-iso" class="btn btn-sm btn-outline">Isometric</button>
            </div>

            <label for="zoom-slider" style="font-size: 12px; color: #666;">Zoom:</label>
            <input type="range" id="zoom-slider" min="50" max="200" value="100" style="width: 100%; margin: 5px 0;">
            <span id="zoom-value" style="font-size: 11px; color: #999;">100%</span>
        </div>

        <!-- Object Rotation Controls -->
        <div class="control-group">
            <h4>üîÑ Object Rotation</h4>

            <label for="rotate-x" style="font-size: 12px; color: #666;">Rotate X:</label>
            <input type="range" id="rotate-x" min="-180" max="180" value="0" style="width: 100%; margin: 5px 0;">
            <span id="rotate-x-value" style="font-size: 11px; color: #999;">0¬∞</span>

            <label for="rotate-y" style="font-size: 12px; color: #666; margin-top: 8px;">Rotate Y:</label>
            <input type="range" id="rotate-y" min="-180" max="180" value="0" style="width: 100%; margin: 5px 0;">
            <span id="rotate-y-value" style="font-size: 11px; color: #999;">0¬∞</span>

            <label for="rotate-z" style="font-size: 12px; color: #666; margin-top: 8px;">Rotate Z:</label>
            <input type="range" id="rotate-z" min="-180" max="180" value="0" style="width: 100%; margin: 5px 0;">
            <span id="rotate-z-value" style="font-size: 11px; color: #999;">0¬∞</span>

            <button id="reset-object" class="btn btn-sm btn-secondary" style="margin-top: 10px; width: 100%;">Reset Object</button>
        </div>

        <div class="control-group" id="info-panel">
            <h4>Model Info</h4>
            <div id="model-stats">
                <p>Vertices: <span id="vertex-count">-</span></p>
                <p>Faces: <span id="face-count">-</span></p>
                <p>Bounding Box: <span id="bbox-size">-</span></p>
            </div>
        </div>

        <div class="control-group">
            <button id="export-screenshot" class="btn btn-primary">üì∏ Screenshot</button>
            <button id="find-similar-btn" class="btn btn-secondary" style="margin-top: 10px; width: 100%;">
                üîç Find Similar (1:Many)
            </button>
        </div>

        <!-- Comparison Control -->
        <div class="control-group">
            <h4>üîç Comparison Mode (1:1)</h4>
            <label for="compare-artifact">Compare with:</label>
            <select id="compare-artifact" class="form-control">
                <option value="">-- Select to compare --</option>
                {% for artifact_id in artifacts %}
                <option value="{{ artifact_id }}">{{ artifact_id }}</option>
                {% endfor %}
            </select>

            <div id="comparison-info" style="display:none; margin-top: 10px;">
                <p style="font-size: 12px; color: #667eea; font-weight: 500;">
                    ‚úì Comparison mode active
                </p>
            </div>
        </div>
    </div>

    <!-- 3D Viewport -->
    <div class="viewer-viewport" id="single-viewport">
        <div id="canvas-container"></div>
        <div id="loading-indicator" class="loading-overlay" style="display:none;">
            <div class="spinner"></div>
            <p id="loading-text">Loading 3D model...</p>
            <p id="loading-percent" style="font-size: 24px; font-weight: bold; margin-top: 10px;">0%</p>
        </div>
    </div>
</div>

<!-- 1:Many Similarity Results Section -->
<div class="comparison-section card" id="similarity-results-section" style="display:none; margin-bottom: 30px;">
    <div class="section-header">
        <h2>üîç Similar Artifacts (1:Many Comparison)</h2>
        <button onclick="document.getElementById('similarity-results-section').style.display='none'" class="btn btn-outline btn-sm">Close</button>
    </div>
    <div id="similarity-results-content" style="margin-top: 20px;"></div>
</div>

<!-- Comparison Results Section -->
<div class="comparison-section" id="comparison-section" style="display:none;">
    <div class="section-header">
        <h2>üîç Comparison Results (1:1)</h2>
    </div>

    <div class="comparison-controls card">
        <div class="similarity-info" id="similarity-info">
            <h4>Similarity Analysis</h4>
            <div class="similarity-score">
                <p>Overall Similarity: <span id="similarity-score">-</span>%</p>
                <div class="progress-bar">
                    <div id="similarity-progress" class="progress-fill"></div>
                </div>
            </div>
            <div id="feature-comparison"></div>
        </div>

        <button id="generate-report" class="btn btn-primary" style="margin-top: 15px;">
            üìÑ Generate PDF Report
        </button>
    </div>

    <!-- Cross-Section Controls -->
    <div class="card" style="margin-bottom: 20px; padding: 20px;">
        <h4>üìè Cross-Section Analysis</h4>

        <!-- Axis Selection -->
        <div style="margin-top: 15px; margin-bottom: 15px;">
            <label style="display: block; margin-bottom: 8px; font-weight: bold;">Section Axis:</label>
            <div style="display: flex; gap: 10px;">
                <label style="display: flex; align-items: center; gap: 5px;">
                    <input type="radio" name="section-axis" value="y" checked>
                    <span>Vertical (Y)</span>
                </label>
                <label style="display: flex; align-items: center; gap: 5px;">
                    <input type="radio" name="section-axis" value="x">
                    <span>Horizontal (X)</span>
                </label>
            </div>
        </div>

        <div style="margin-top: 15px;">
            <label for="section-height-slider" style="display: block; margin-bottom: 8px;">
                Section Position: <span id="section-height-value">0.0</span> mm
            </label>
            <input type="range" id="section-height-slider" min="0" max="100" value="50"
                   style="width: 100%; margin-bottom: 15px;">
        </div>
        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
            <button id="toggle-mesh-btn" class="btn btn-secondary">
                üëÅÔ∏è Hide Mesh
            </button>
            <button id="toggle-section-btn" class="btn btn-secondary">
                ‚úÇÔ∏è Show Section
            </button>
            <button id="trim-mesh-btn" class="btn btn-secondary">
                ‚úÇÔ∏è Trim Mesh
            </button>
            <button id="front-view-btn" class="btn btn-secondary">
                üîÑ Front View
            </button>
            <button id="toggle-rulers-btn" class="btn btn-secondary">
                üìè Hide Rulers
            </button>
        </div>
    </div>

    <div class="split-viewport">
        <div id="canvas-container-left" class="viewport-half">
            <h4 id="left-label">Original</h4>
            <div id="left-measurements" class="viewer-measurements">
                <div class="measurements-content">
                    <p><strong>Dimensions:</strong></p>
                    <p>Length: <span id="left-length">-</span> mm</p>
                    <p>Width: <span id="left-width">-</span> mm</p>
                    <p>Height: <span id="left-height">-</span> mm</p>
                    <p>Volume: <span id="left-volume">-</span> mm¬≥</p>
                </div>
            </div>
        </div>
        <div id="canvas-container-right" class="viewport-half">
            <h4 id="right-label">Comparison</h4>
            <div id="right-measurements" class="viewer-measurements">
                <div class="measurements-content">
                    <p><strong>Dimensions:</strong></p>
                    <p>Length: <span id="right-length">-</span> mm</p>
                    <p>Width: <span id="right-width">-</span> mm</p>
                    <p>Height: <span id="right-height">-</span> mm</p>
                    <p>Volume: <span id="right-volume">-</span> mm¬≥</p>
                </div>
            </div>
        </div>
    </div>
</div>

<style>
.viewer-container {
    display: grid;
    grid-template-columns: 300px 1fr;
    gap: 20px;
    margin-bottom: 30px;
}

.viewer-controls {
    padding: 20px;
}

.control-group {
    margin-bottom: 20px;
    padding-bottom: 15px;
    border-bottom: 1px solid #eee;
}

.control-group:last-child {
    border-bottom: none;
}

.control-group h4 {
    margin: 0 0 10px 0;
    color: #4a5568;
    font-size: 14px;
}

.control-group label {
    display: block;
    margin: 8px 0;
    font-size: 14px;
}

.control-group input[type="checkbox"] {
    margin-right: 8px;
}

.viewer-viewport {
    position: relative;
    background: #f7fafc;
    border-radius: 8px;
    overflow: hidden;
    height: 600px;
}

#canvas-container {
    width: 100%;
    height: 100%;
}

.loading-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(255, 255, 255, 0.9);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 10;
}

.spinner {
    width: 50px;
    height: 50px;
    border: 4px solid #e2e8f0;
    border-top-color: #667eea;
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

#model-stats p {
    margin: 5px 0;
    font-size: 13px;
    color: #718096;
}

.comparison-section {
    margin-top: 40px;
}

.section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
}

.comparison-controls {
    padding: 20px;
    margin-bottom: 20px;
}

.split-viewport {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    height: 600px;
}

.viewport-half {
    background: #f7fafc;
    border-radius: 8px;
    position: relative;
    overflow: hidden;
}

.viewport-half h4 {
    position: absolute;
    top: 10px;
    left: 10px;
    background: rgba(255, 255, 255, 0.9);
    padding: 8px 15px;
    border-radius: 4px;
    margin: 0;
    z-index: 5;
    font-size: 14px;
}

.viewer-measurements {
    position: absolute;
    bottom: 10px;
    left: 10px;
    background: rgba(255, 255, 255, 0.95);
    padding: 10px 15px;
    border-radius: 4px;
    z-index: 5;
    font-size: 12px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.viewer-measurements .measurements-content p {
    margin: 3px 0;
    color: #333;
}

.viewer-measurements .measurements-content strong {
    color: #667eea;
}

.similarity-info {
    margin-top: 20px;
    padding-top: 20px;
    border-top: 1px solid #eee;
}

.similarity-score {
    margin: 15px 0;
}

.similarity-score p {
    margin-bottom: 8px;
    font-weight: 500;
}

.progress-bar {
    width: 100%;
    height: 24px;
    background: #e2e8f0;
    border-radius: 12px;
    overflow: hidden;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
    transition: width 0.5s ease;
    width: 0%;
}

#feature-comparison {
    margin-top: 15px;
    font-size: 13px;
}

#feature-comparison .feature-item {
    display: flex;
    justify-content: space-between;
    padding: 8px 0;
    border-bottom: 1px solid #f0f0f0;
}

#feature-comparison .feature-item:last-child {
    border-bottom: none;
}

.btn-secondary {
    background: #718096;
    color: white;
    margin-right: 5px;
    margin-bottom: 5px;
}

.btn-secondary:hover {
    background: #4a5568;
}
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/MTLLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
// 3D Viewer Application
class ArtifactViewer {
    constructor(containerId) {
        this.container = document.getElementById(containerId);
        this.containerId = containerId;  // Store container ID to identify which viewer this is
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.controls = null;
        this.currentMesh = null;
        this.axes = null;
        this.grid = null;
        this.rulers = { vertical: null, horizontal: null };
        this.crossSectionPlane = null;
        this.crossSectionMesh = null;
        this.sectionOutline = null;  // For showing section profile/silhouette
        this.showMesh = true;
        this.showSection = false;
        this.sectionHeight = 0;
        this.sectionAxis = 'y';  // 'y' or 'x'
        this.clippingPlanes = [];
        this.isTrimmed = false;  // Track if mesh is trimmed
        this.init();
    }

    init() {
        // Scene
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0xf7fafc);

        // Camera - FRONT VIEW for archaeological axes
        this.camera = new THREE.PerspectiveCamera(
            75,
            this.container.clientWidth / this.container.clientHeight,
            0.1,
            1000
        );
        // Position camera in front (looking at Z=0 from positive Z)
        this.camera.position.set(0, 0, 8);

        // Renderer
        this.renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
        this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
        this.renderer.shadowMap.enabled = true;
        this.renderer.localClippingEnabled = true;  // Enable clipping planes for sections
        this.container.appendChild(this.renderer.domElement);

        // Controls
        this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        this.scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 5);
        directionalLight.castShadow = true;
        this.scene.add(directionalLight);

        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight2.position.set(-10, -10, -5);
        this.scene.add(directionalLight2);

        // Axes helper
        this.axes = new THREE.AxesHelper(5);
        this.scene.add(this.axes);

        // Grid helper
        this.grid = new THREE.GridHelper(10, 10);
        this.scene.add(this.grid);

        // Resize handler
        window.addEventListener('resize', () => this.onWindowResize());

        // Animation loop
        this.animate();
    }

    async loadModel(artifactId) {
        document.getElementById('loading-indicator').style.display = 'flex';

        // Remove existing mesh
        if (this.currentMesh) {
            this.scene.remove(this.currentMesh);
        }

        // Fetch artifact metadata to get mesh_units and texture info
        let meshUnits = 'cm'; // Default
        let hasTextures = false;
        let mtlPath = null;
        try {
            const metadataResponse = await fetch(`/web/artifact-metadata/${artifactId}`);
            if (metadataResponse.ok) {
                const metadata = await metadataResponse.json();
                meshUnits = metadata.mesh_units || 'cm';
                hasTextures = metadata.has_textures || false;
                mtlPath = metadata.mtl_path;
                console.log(`Artifact ${artifactId}: mesh_units = ${meshUnits}, hasTextures = ${hasTextures}`);
            }
        } catch (e) {
            console.warn(`Could not fetch metadata for ${artifactId}, using default cm`, e);
        }

        // Scale factors to convert to mm (standard display unit)
        const SCALE_TO_MM = {
            'mm': 1.0,      // Already in mm
            'cm': 10.0,     // cm to mm
            'm': 1000.0,    // m to mm
            'in': 25.4      // inches to mm
        };
        const meshScaleFactor = SCALE_TO_MM[meshUnits] || 10.0;
        this.currentMeshUnits = meshUnits;
        this.meshScaleToMm = meshScaleFactor;

        const meshUrl = `/web/mesh-file/${artifactId}`;

        // Load with or without textures
        if (hasTextures && mtlPath) {
            // Load with MTL and textures
            console.log(`üñºÔ∏è Loading ${artifactId} with textures...`);
            console.log(`üìÅ MTL path: ${mtlPath}`);
            console.log(`üîó Texture base URL: /web/texture-file/${artifactId}/`);

            // Add texture load manager for debugging
            const loadingManager = new THREE.LoadingManager();
            loadingManager.onLoad = () => console.log('‚úÖ All textures loaded');
            loadingManager.onError = (url) => console.error('‚ùå Texture load error:', url);
            loadingManager.onProgress = (url, loaded, total) => {
                console.log(`üì• Loading: ${url} (${loaded}/${total})`);
            };

            // Pass manager to constructor (setManager doesn't exist in r128)
            const mtlLoader = new THREE.MTLLoader(loadingManager);
            // Use setResourcePath for textures (not setPath which affects MTL loading)
            mtlLoader.setResourcePath(`/web/texture-file/${artifactId}/`);

            mtlLoader.load(
                `/web/mtl-file/${artifactId}`,
                (materials) => {
                    console.log('‚úÖ MTL loaded successfully');
                    console.log('üìã Materials:', Object.keys(materials.materials || {}));
                    materials.preload();

                    const objLoader = new THREE.OBJLoader();
                    objLoader.setMaterials(materials);

                    objLoader.load(
                        meshUrl,
                        (object) => this.onModelLoaded(object, artifactId, meshScaleFactor),
                        (xhr) => this.onLoadProgress(xhr),
                        (error) => this.onLoadError(error)
                    );
                },
                (xhr) => console.log(`MTL: ${(xhr.loaded / xhr.total * 100).toFixed(0)}% loaded`),
                (error) => {
                    console.warn('‚ùå MTL load failed, falling back to simple OBJ:', error);
                    // Fallback to simple OBJ loading
                    this.loadModelSimple(artifactId, meshScaleFactor, meshUrl);
                }
            );
        } else {
            // Load without textures (simple OBJ)
            this.loadModelSimple(artifactId, meshScaleFactor, meshUrl);
        }
    }

    loadModelSimple(artifactId, meshScaleFactor, meshUrl) {
        const loader = new THREE.OBJLoader();

        loader.load(
            meshUrl,
            (object) => this.onModelLoaded(object, artifactId, meshScaleFactor, false),
            (xhr) => this.onLoadProgress(xhr),
            (error) => this.onLoadError(error)
        );
    }

    onModelLoaded(object, artifactId, meshScaleFactor, hasTextures = true) {
        this.currentMesh = object;

        // Get ORIGINAL dimensions before scaling
        const originalBox = new THREE.Box3().setFromObject(object);
        const originalSize = originalBox.getSize(new THREE.Vector3());

        // Store original dimensions in mm using the correct scale factor
        this.originalDimensions = {
            width: originalSize.x * meshScaleFactor,
            height: originalSize.y * meshScaleFactor,
            depth: originalSize.z * meshScaleFactor
        };
        console.log(`Original dimensions (mm): ${this.originalDimensions.width.toFixed(1)} x ${this.originalDimensions.height.toFixed(1)} x ${this.originalDimensions.depth.toFixed(1)}`);

        // Calculate the scale to fit mesh in viewer
        const maxDim = Math.max(originalSize.x, originalSize.y, originalSize.z);
        const viewerScale = 4 / maxDim;
        object.scale.multiplyScalar(viewerScale);

        // Store scale factor for ruler calculations
        this.meshToViewerScale = viewerScale;

        // Rotate to make axes stand VERTICALLY (blade up, shaft down)
        // Rotate 90 degrees around Z-axis to stand upright
        object.rotation.z = Math.PI / 2;

        // NOW center the model AFTER rotation
        const box2 = new THREE.Box3().setFromObject(object);
        const center = box2.getCenter(new THREE.Vector3());
        object.position.sub(center);

        // Place object at origin with base on the grid
        object.position.y = 0;

        // Apply default material only if no textures loaded
        if (!hasTextures) {
            object.traverse((child) => {
                if (child instanceof THREE.Mesh) {
                    child.material = new THREE.MeshPhongMaterial({
                        color: 0xccaa88,
                        shininess: 30,
                        flatShading: false
                    });
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
        } else {
            // Ensure shadows work with textures
            object.traverse((child) => {
                if (child instanceof THREE.Mesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
        }

        this.scene.add(object);
        this.updateModelStats(object);

        // Add metric rulers for comparison viewers (with REAL dimensions)
        const box3 = new THREE.Box3().setFromObject(object);
        this.createMetricRulers(box3);

        // Setup ruler click interaction (only once)
        if (!this.raycaster) {
            this.setupRulerClickInteraction();
        }

        // Display measurements for comparison viewers
        this.displayMeasurements(artifactId, box3);

        document.getElementById('loading-indicator').style.display = 'none';
    }

    onLoadProgress(xhr) {
        // Update progress percentage
        if (xhr.lengthComputable) {
            const percentComplete = Math.round((xhr.loaded / xhr.total) * 100);
            const loadingPercent = document.getElementById('loading-percent');
            const loadingText = document.getElementById('loading-text');
            if (loadingPercent) {
                loadingPercent.textContent = percentComplete + '%';
            }
            if (loadingText) {
                loadingText.textContent = `Loading 3D model... (${(xhr.loaded / 1024 / 1024).toFixed(1)}MB / ${(xhr.total / 1024 / 1024).toFixed(1)}MB)`;
            }
            console.log(percentComplete + '% loaded');
        }
    }

    onLoadError(error) {
        console.error('Error loading model:', error);
        document.getElementById('loading-indicator').style.display = 'none';
        alert('Error loading 3D model. Please check the console.');
    }

    updateModelStats(object) {
        let vertices = 0;
        let faces = 0;

        object.traverse((child) => {
            if (child instanceof THREE.Mesh) {
                vertices += child.geometry.attributes.position.count;
                faces += child.geometry.index ? child.geometry.index.count / 3 : vertices / 3;
            }
        });

        document.getElementById('vertex-count').textContent = vertices.toLocaleString();
        document.getElementById('face-count').textContent = Math.floor(faces).toLocaleString();

        // Display REAL dimensions in mm from originalDimensions
        if (this.originalDimensions) {
            const w = this.originalDimensions.width.toFixed(1);
            const h = this.originalDimensions.height.toFixed(1);
            const d = this.originalDimensions.depth.toFixed(1);
            document.getElementById('bbox-size').textContent = `${w} √ó ${h} √ó ${d} mm`;
        } else {
            const box = new THREE.Box3().setFromObject(object);
            const size = box.getSize(new THREE.Vector3());
            document.getElementById('bbox-size').textContent =
                `${size.x.toFixed(2)} √ó ${size.y.toFixed(2)} √ó ${size.z.toFixed(2)}`;
        }
    }

    async displayMeasurements(artifactId, boundingBox) {
        // Determine which viewer this is (left or right)
        let prefix = '';
        if (this.containerId === 'canvas-container-left') {
            prefix = 'left';
        } else if (this.containerId === 'canvas-container-right') {
            prefix = 'right';
        } else {
            return;  // Not a comparison viewer
        }

        // Use REAL dimensions in mm from originalDimensions
        // After rotation: original width -> viewer height (length), original height -> viewer width
        let length, width, height, volume;

        if (this.originalDimensions) {
            // Real measurements in mm
            length = this.originalDimensions.width.toFixed(1);   // rotated to vertical
            width = this.originalDimensions.height.toFixed(1);   // rotated to horizontal
            height = this.originalDimensions.depth.toFixed(1);   // depth stays depth
            volume = (this.originalDimensions.width * this.originalDimensions.height * this.originalDimensions.depth).toFixed(0);
        } else {
            // Fallback to viewer units (should not happen)
            const size = boundingBox.getSize(new THREE.Vector3());
            length = (size.y * 10).toFixed(1);  // Approximate cm to mm
            width = (size.x * 10).toFixed(1);
            height = (size.z * 10).toFixed(1);
            volume = (size.x * size.y * size.z * 1000).toFixed(0);
        }

        // Update display
        const lengthEl = document.getElementById(`${prefix}-length`);
        const widthEl = document.getElementById(`${prefix}-width`);
        const heightEl = document.getElementById(`${prefix}-height`);
        const volumeEl = document.getElementById(`${prefix}-volume`);

        if (lengthEl) lengthEl.textContent = length;
        if (widthEl) widthEl.textContent = width;
        if (heightEl) heightEl.textContent = height;
        if (volumeEl) volumeEl.textContent = volume;
    }

    toggleWireframe() {
        if (this.currentMesh) {
            this.currentMesh.traverse((child) => {
                if (child instanceof THREE.Mesh) {
                    child.material.wireframe = !child.material.wireframe;
                }
            });
        }
    }

    resetCamera() {
        // Reset to FRONT VIEW (archaeological standard)
        this.camera.position.set(0, 0, 8);
        this.camera.lookAt(0, 0, 0);
        this.controls.reset();
    }

    captureScreenshot() {
        this.renderer.render(this.scene, this.camera);
        const dataURL = this.renderer.domElement.toDataURL('image/png');

        const link = document.createElement('a');
        link.download = `artifact_${Date.now()}.png`;
        link.href = dataURL;
        link.click();
    }

    createMetricRulers(meshBounds) {
        // Remove existing rulers
        if (this.rulers.vertical) {
            this.scene.remove(this.rulers.vertical);
            this.scene.remove(this.rulers.horizontal);
        }

        const rulerGroup = new THREE.Group();
        const rulerGroupH = new THREE.Group();

        // Get viewer dimensions (normalized bounding box)
        const viewerHeight = meshBounds.max.y - meshBounds.min.y;
        const viewerWidth = meshBounds.max.x - meshBounds.min.x;

        // Get REAL dimensions in mm from originalDimensions
        // After rotation (Z by 90¬∞), the original Y becomes viewer X, original X becomes viewer Y
        const realHeightMm = this.originalDimensions ? this.originalDimensions.width : viewerHeight * 10;  // rotated
        const realWidthMm = this.originalDimensions ? this.originalDimensions.height : viewerWidth * 10;   // rotated

        // Calculate scale from viewer units to mm
        const heightScaleToMm = realHeightMm / viewerHeight;
        const widthScaleToMm = realWidthMm / viewerWidth;

        // VERTICAL RULER (Y axis) - shows real height in mm
        const verticalMaterial = new THREE.LineBasicMaterial({ color: 0x333333 });

        // Create ruler ticks every 10mm in real space
        const tickIntervalMm = 10; // 10mm tick marks
        const numVerticalTicks = Math.ceil(realHeightMm / tickIntervalMm);

        for (let i = 0; i <= numVerticalTicks; i++) {
            const realMm = i * tickIntervalMm;
            if (realMm > realHeightMm) break;

            // Convert mm position to viewer units
            const viewerY = meshBounds.min.y + (realMm / heightScaleToMm);
            const isMajorTick = (i % 5 === 0); // Major tick every 50mm

            const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(meshBounds.max.x + 0.2, viewerY, 0),
                new THREE.Vector3(meshBounds.max.x + (isMajorTick ? 0.4 : 0.3), viewerY, 0)
            ]);
            const line = new THREE.Line(lineGeometry, verticalMaterial);
            rulerGroup.add(line);

            // Add labels at major ticks (every 50mm)
            if (isMajorTick) {
                this.addRulerLabel(meshBounds.max.x + 0.5, viewerY, 0, realMm.toFixed(0), rulerGroup);
            }
        }

        // HORIZONTAL RULER (X axis) - shows real width in mm
        const numHorizontalTicks = Math.ceil(realWidthMm / tickIntervalMm);

        for (let i = 0; i <= numHorizontalTicks; i++) {
            const realMm = i * tickIntervalMm;
            if (realMm > realWidthMm) break;

            // Convert mm position to viewer units
            const viewerX = meshBounds.min.x + (realMm / widthScaleToMm);
            const isMajorTick = (i % 5 === 0); // Major tick every 50mm

            const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(viewerX, meshBounds.min.y - 0.2, 0),
                new THREE.Vector3(viewerX, meshBounds.min.y - (isMajorTick ? 0.4 : 0.3), 0)
            ]);
            const line = new THREE.Line(lineGeometry, verticalMaterial);
            rulerGroupH.add(line);

            // Add labels at major ticks (every 50mm)
            if (isMajorTick) {
                this.addRulerLabel(viewerX, meshBounds.min.y - 0.5, 0, realMm.toFixed(0), rulerGroupH);
            }
        }

        this.rulers.vertical = rulerGroup;
        this.rulers.horizontal = rulerGroupH;
        this.scene.add(rulerGroup);
        this.scene.add(rulerGroupH);
    }

    addRulerLabel(x, y, z, text, group) {
        // Create text sprite for ruler labels
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 128;
        canvas.height = 64;
        context.fillStyle = '#333333';
        context.font = 'Bold 32px Arial';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillText(text + ' mm', 64, 32);

        const texture = new THREE.CanvasTexture(canvas);
        const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.position.set(x, y, z);
        sprite.scale.set(0.5, 0.25, 1);
        group.add(sprite);
    }

    updateCrossSection(position) {
        // Remove existing cross section elements
        if (this.crossSectionPlane) {
            this.scene.remove(this.crossSectionPlane);
        }
        if (this.sectionOutline) {
            this.scene.remove(this.sectionOutline);
        }

        if (!this.currentMesh) return;

        const bounds = new THREE.Box3().setFromObject(this.currentMesh);
        const width = bounds.max.x - bounds.min.x;
        const height = bounds.max.y - bounds.min.y;
        const depth = bounds.max.z - bounds.min.z;

        // Create clipping plane based on axis
        let planeNormal, planeConstant;
        let planeGeometry, planeRotation, planePosition;

        if (this.sectionAxis === 'y') {
            // Horizontal plane (cuts through Y axis)
            planeNormal = new THREE.Vector3(0, 1, 0);
            planeConstant = -position;
            planeGeometry = new THREE.PlaneGeometry(width + 2, depth + 2);
            planeRotation = new THREE.Euler(Math.PI / 2, 0, 0);
            planePosition = new THREE.Vector3(0, position, 0);
        } else {
            // Vertical plane (cuts through X axis)
            planeNormal = new THREE.Vector3(1, 0, 0);
            planeConstant = -position;
            planeGeometry = new THREE.PlaneGeometry(depth + 2, height + 2);
            planeRotation = new THREE.Euler(0, Math.PI / 2, 0);
            planePosition = new THREE.Vector3(position, 0, 0);
        }

        // Create semi-transparent cutting plane visualization
        const planeMaterial = new THREE.MeshBasicMaterial({
            color: 0xff0000,
            transparent: true,
            opacity: 0.3,
            side: THREE.DoubleSide
        });

        this.crossSectionPlane = new THREE.Mesh(planeGeometry, planeMaterial);
        this.crossSectionPlane.rotation.copy(planeRotation);
        this.crossSectionPlane.position.copy(planePosition);
        this.crossSectionPlane.visible = this.showSection;
        this.scene.add(this.crossSectionPlane);

        // Create section outline (sagoma/silhouette)
        this.createSectionOutline(position);

        this.sectionHeight = position;
    }

    createSectionOutline(position) {
        // This method is simplified - we don't create wireframe anymore
        // The trim functionality will be handled by the trimMesh method
        if (this.sectionOutline) {
            this.scene.remove(this.sectionOutline);
            this.sectionOutline = null;
        }
    }

    trimMesh(enable) {
        if (!this.currentMesh || this.sectionHeight === 0) return;

        this.isTrimmed = enable;

        // Create clipping planes based on axis
        let clippingPlane;
        if (this.sectionAxis === 'y') {
            clippingPlane = new THREE.Plane(new THREE.Vector3(0, -1, 0), this.sectionHeight);
        } else {
            clippingPlane = new THREE.Plane(new THREE.Vector3(-1, 0, 0), this.sectionHeight);
        }

        // Apply clipping to all mesh materials
        this.currentMesh.traverse((child) => {
            if (child instanceof THREE.Mesh) {
                if (enable) {
                    // Enable clipping
                    child.material.clippingPlanes = [clippingPlane];
                    child.material.clipShadows = true;
                    child.material.needsUpdate = true;
                } else {
                    // Disable clipping
                    child.material.clippingPlanes = [];
                    child.material.needsUpdate = true;
                }
            }
        });

        // Update renderer clipping
        this.renderer.localClippingEnabled = enable;
    }

    toggleMeshVisibility(show) {
        this.showMesh = show;
        if (this.currentMesh) {
            this.currentMesh.visible = show;
        }
    }

    toggleSectionVisibility(show) {
        this.showSection = show;
        if (this.crossSectionPlane) {
            this.crossSectionPlane.visible = show;
        }
    }

    setupRulerClickInteraction() {
        // Setup raycasting for ruler clicks
        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();

        const onCanvasClick = (event) => {
            if (!this.currentMesh) return;

            const rect = this.renderer.domElement.getBoundingClientRect();
            this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            this.raycaster.setFromCamera(this.mouse, this.camera);

            // Check intersection with rulers
            const intersectableObjects = [];
            if (this.rulers.vertical) {
                this.rulers.vertical.children.forEach(child => {
                    if (child instanceof THREE.Line || child instanceof THREE.Sprite) {
                        intersectableObjects.push(child);
                    }
                });
            }

            const intersects = this.raycaster.intersectObjects(intersectableObjects, false);

            if (intersects.length > 0) {
                // Get Y position from intersection
                const yPos = intersects[0].point.y;

                // Update cross-section to this height
                this.updateCrossSection(yPos);
                this.sectionHeight = yPos;

                // Show the section if not already visible
                if (!this.showSection) {
                    this.toggleSectionVisibility(true);
                }

                // Update UI slider to match
                const box = new THREE.Box3().setFromObject(this.currentMesh);
                const percentage = ((yPos - box.min.y) / (box.max.y - box.min.y)) * 100;
                const slider = document.getElementById('section-height-slider');
                if (slider) {
                    slider.value = percentage;
                    document.getElementById('section-height-value').textContent = yPos.toFixed(1);
                }
            }
        };

        this.renderer.domElement.addEventListener('click', onCanvasClick);
    }

    animate() {
        requestAnimationFrame(() => this.animate());

        if (document.getElementById('auto-rotate').checked && this.currentMesh) {
            this.currentMesh.rotation.y += 0.005;
        }

        this.controls.update();
        this.renderer.render(this.scene, this.camera);
    }

    onWindowResize() {
        this.camera.aspect = this.container.clientWidth / this.container.clientHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
    }
}

// Initialize viewer
let mainViewer = null;
let leftViewer = null;
let rightViewer = null;

document.addEventListener('DOMContentLoaded', () => {
    mainViewer = new ArtifactViewer('canvas-container');

    // Artifact selection
    document.getElementById('artifact-select').addEventListener('change', (e) => {
        const artifactId = e.target.value;
        if (artifactId) {
            mainViewer.loadModel(artifactId);
        }
    });

    // Controls
    document.getElementById('reset-camera').addEventListener('click', () => {
        mainViewer.resetCamera();
    });

    document.getElementById('wireframe-toggle').addEventListener('click', () => {
        mainViewer.toggleWireframe();
    });

    document.getElementById('show-axes').addEventListener('change', (e) => {
        mainViewer.axes.visible = e.target.checked;
    });

    document.getElementById('show-grid').addEventListener('change', (e) => {
        mainViewer.grid.visible = e.target.checked;
    });

    document.getElementById('export-screenshot').addEventListener('click', () => {
        mainViewer.captureScreenshot();
    });

    document.getElementById('fullscreen-btn').addEventListener('click', () => {
        const container = document.querySelector('.viewer-viewport');
        if (container.requestFullscreen) {
            container.requestFullscreen();
        }
    });

    // Camera preset views
    document.getElementById('view-top').addEventListener('click', () => {
        if (mainViewer && mainViewer.camera) {
            mainViewer.camera.position.set(0, 100, 0);
            mainViewer.camera.lookAt(0, 0, 0);
            mainViewer.controls.update();
        }
    });

    document.getElementById('view-front').addEventListener('click', () => {
        if (mainViewer && mainViewer.camera) {
            mainViewer.camera.position.set(0, 0, 100);
            mainViewer.camera.lookAt(0, 0, 0);
            mainViewer.controls.update();
        }
    });

    document.getElementById('view-side').addEventListener('click', () => {
        if (mainViewer && mainViewer.camera) {
            mainViewer.camera.position.set(100, 0, 0);
            mainViewer.camera.lookAt(0, 0, 0);
            mainViewer.controls.update();
        }
    });

    document.getElementById('view-iso').addEventListener('click', () => {
        if (mainViewer && mainViewer.camera) {
            mainViewer.camera.position.set(70, 70, 70);
            mainViewer.camera.lookAt(0, 0, 0);
            mainViewer.controls.update();
        }
    });

    // Zoom control
    document.getElementById('zoom-slider').addEventListener('input', (e) => {
        const zoomValue = e.target.value;
        document.getElementById('zoom-value').textContent = zoomValue + '%';
        if (mainViewer && mainViewer.camera) {
            const scale = 100 / zoomValue;
            mainViewer.camera.zoom = scale;
            mainViewer.camera.updateProjectionMatrix();
        }
    });

    // Object rotation controls
    let objectRotation = { x: 0, y: 0, z: 0 };

    document.getElementById('rotate-x').addEventListener('input', (e) => {
        objectRotation.x = parseFloat(e.target.value);
        document.getElementById('rotate-x-value').textContent = e.target.value + '¬∞';
        updateObjectRotation();
    });

    document.getElementById('rotate-y').addEventListener('input', (e) => {
        objectRotation.y = parseFloat(e.target.value);
        document.getElementById('rotate-y-value').textContent = e.target.value + '¬∞';
        updateObjectRotation();
    });

    document.getElementById('rotate-z').addEventListener('input', (e) => {
        objectRotation.z = parseFloat(e.target.value);
        document.getElementById('rotate-z-value').textContent = e.target.value + '¬∞';
        updateObjectRotation();
    });

    function updateObjectRotation() {
        if (mainViewer && mainViewer.mesh) {
            mainViewer.mesh.rotation.set(
                objectRotation.x * Math.PI / 180,
                objectRotation.y * Math.PI / 180,
                objectRotation.z * Math.PI / 180
            );
        }
    }

    document.getElementById('reset-object').addEventListener('click', () => {
        objectRotation = { x: 0, y: 0, z: 0 };
        document.getElementById('rotate-x').value = 0;
        document.getElementById('rotate-y').value = 0;
        document.getElementById('rotate-z').value = 0;
        document.getElementById('rotate-x-value').textContent = '0¬∞';
        document.getElementById('rotate-y-value').textContent = '0¬∞';
        document.getElementById('rotate-z-value').textContent = '0¬∞';
        document.getElementById('zoom-slider').value = 100;
        document.getElementById('zoom-value').textContent = '100%';

        if (mainViewer) {
            if (mainViewer.mesh) {
                mainViewer.mesh.rotation.set(0, 0, 0);
            }
            if (mainViewer.camera) {
                mainViewer.camera.zoom = 1;
                mainViewer.camera.updateProjectionMatrix();
            }
        }
    });

    // Find Similar (1:Many) button
    document.getElementById('find-similar-btn').addEventListener('click', async () => {
        const selectedArtifact = document.getElementById('artifact-select').value;

        if (!selectedArtifact) {
            alert('Please select an artifact first!');
            return;
        }

        const resultsSection = document.getElementById('similarity-results-section');
        const resultsContent = document.getElementById('similarity-results-content');

        resultsSection.style.display = 'block';
        resultsContent.innerHTML = '<p>‚è≥ Searching for similar artifacts...</p>';

        try {
            const response = await fetch('/web/find-similar', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    query_id: selectedArtifact,
                    n_results: 10,
                    metric: 'cosine',
                    min_similarity: 0.0  // Set to 0 to show all results (cosine can be negative)
                })
            });

            const data = await response.json();

            if (response.ok && data.results) {
                let html = '<div style="margin-top: 15px;">';
                html += `<p><strong>Found ${data.results.length} similar artifacts:</strong></p>`;
                html += '<table class="feature-table" style="width: 100%; margin-top: 10px; background: white; border-collapse: collapse;">';
                html += '<thead><tr style="background: #f3f4f6;"><th style="padding: 10px; border: 1px solid #e5e7eb;">Rank</th><th style="padding: 10px; border: 1px solid #e5e7eb;">Artifact ID</th><th style="padding: 10px; border: 1px solid #e5e7eb;">Similarity</th><th style="padding: 10px; border: 1px solid #e5e7eb;">Volume</th><th style="padding: 10px; border: 1px solid #e5e7eb;">Length</th><th style="padding: 10px; border: 1px solid #e5e7eb;">Actions</th></tr></thead>';
                html += '<tbody>';

                data.results.forEach((result, index) => {
                    if (result.artifact_id !== selectedArtifact) {
                        const similarityPercent = (result.similarity_score * 100).toFixed(1);
                        const volume = result.features.volume ? result.features.volume.toFixed(2) : 'N/A';
                        const length = result.features.length ? result.features.length.toFixed(2) : 'N/A';
                        const color = result.similarity_score > 0.8 ? '#10b981' : result.similarity_score > 0.6 ? '#f59e0b' : '#6b7280';

                        html += `<tr style="border-bottom: 1px solid #e5e7eb;">
                            <td style="padding: 10px; text-align: center;">${index + 1}</td>
                            <td style="padding: 10px;"><strong>${result.artifact_id}</strong></td>
                            <td style="padding: 10px;"><span style="color: ${color}; font-weight: bold; font-size: 16px;">${similarityPercent}%</span></td>
                            <td style="padding: 10px;">${volume} mm¬≥</td>
                            <td style="padding: 10px;">${length} mm</td>
                            <td style="padding: 10px;">
                                <button onclick="document.getElementById('compare-artifact').value='${result.artifact_id}'; document.getElementById('compare-artifact').dispatchEvent(new Event('change'));" class="btn btn-sm btn-primary">Compare 1:1</button>
                            </td>
                        </tr>`;
                    }
                });

                html += '</tbody></table></div>';
                resultsContent.innerHTML = html;
            } else {
                resultsContent.innerHTML = `<p style="color: #ef4444;">‚ùå Error: ${data.error || 'Unknown error'}</p>`;
            }
        } catch (error) {
            resultsContent.innerHTML = `<p style="color: #ef4444;">‚ùå Error: ${error.message}</p>`;
        }
    });

    // Comparison mode
    document.getElementById('compare-artifact').addEventListener('change', async (e) => {
        const compareId = e.target.value;
        const originalId = document.getElementById('artifact-select').value;

        if (!originalId) {
            alert('Please select the first artifact before comparing!');
            e.target.value = '';
            return;
        }

        if (!compareId) {
            // User cleared the comparison
            document.getElementById('comparison-section').style.display = 'none';
            document.getElementById('single-viewport').style.display = 'block';
            document.getElementById('comparison-info').style.display = 'none';
            return;
        }

        // Show comparison mode indicator
        document.getElementById('comparison-info').style.display = 'block';

        // Hide single viewport, show comparison section
        document.getElementById('single-viewport').style.display = 'none';
        document.getElementById('comparison-section').style.display = 'block';

        // Initialize comparison viewers if needed
        if (!leftViewer) {
            leftViewer = new ArtifactViewer('canvas-container-left');
            rightViewer = new ArtifactViewer('canvas-container-right');
        }

        leftViewer.loadModel(originalId);
        rightViewer.loadModel(compareId);

        document.getElementById('left-label').textContent = originalId;
        document.getElementById('right-label').textContent = compareId;

        // Fetch similarity data
        try {
            const response = await fetch('/web/compare-artifacts', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ artifact1: originalId, artifact2: compareId })
            });

            const data = await response.json();
            displaySimilarity(data);
        } catch (error) {
            console.error('Error fetching comparison:', error);
            alert('Error loading comparison data');
        }
    });

    document.getElementById('generate-report').addEventListener('click', async () => {
        const originalId = document.getElementById('artifact-select').value;
        const compareId = document.getElementById('compare-artifact').value;

        if (!originalId || !compareId) {
            alert('Please select two artifacts to compare before generating report');
            return;
        }

        // Show loading state
        const btn = document.getElementById('generate-report');
        const originalText = btn.textContent;
        btn.textContent = '‚è≥ Generating PDF...';
        btn.disabled = true;

        try {
            const response = await fetch('/web/generate-report', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ artifact1: originalId, artifact2: compareId })
            });

            if (!response.ok) {
                throw new Error('Failed to generate report');
            }

            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `comparison_report_${originalId}_${compareId}.pdf`;
            a.click();

            // Cleanup
            setTimeout(() => window.URL.revokeObjectURL(url), 100);

            // Show success
            btn.textContent = '‚úì Report Downloaded!';
            setTimeout(() => {
                btn.textContent = originalText;
                btn.disabled = false;
            }, 2000);
        } catch (error) {
            console.error('Error generating report:', error);
            alert('Error generating PDF report. Please try again.');
            btn.textContent = originalText;
            btn.disabled = false;
        }
    });

    // Cross-section controls
    const sectionSlider = document.getElementById('section-height-slider');
    const sectionHeightValue = document.getElementById('section-height-value');
    const toggleMeshBtn = document.getElementById('toggle-mesh-btn');
    const toggleSectionBtn = document.getElementById('toggle-section-btn');
    const trimMeshBtn = document.getElementById('trim-mesh-btn');
    const frontViewBtn = document.getElementById('front-view-btn');
    const toggleRulersBtn = document.getElementById('toggle-rulers-btn');

    let meshVisible = true;
    let sectionVisible = false;
    let trimEnabled = false;
    let rulersVisible = true;

    // Section position slider
    sectionSlider.addEventListener('input', (e) => {
        const percentage = parseFloat(e.target.value) / 100;

        // Get selected axis
        const selectedAxis = document.querySelector('input[name="section-axis"]:checked').value;

        if (leftViewer && leftViewer.currentMesh) {
            const box = new THREE.Box3().setFromObject(leftViewer.currentMesh);
            let position;

            if (selectedAxis === 'y') {
                position = box.min.y + (box.max.y - box.min.y) * percentage;
            } else {
                position = box.min.x + (box.max.x - box.min.x) * percentage;
            }

            sectionHeightValue.textContent = position.toFixed(1);
            leftViewer.updateCrossSection(position);
            leftViewer.sectionHeight = position;

            // Update trim if enabled
            if (trimEnabled) {
                leftViewer.trimMesh(true);
            }
        }

        if (rightViewer && rightViewer.currentMesh) {
            const box = new THREE.Box3().setFromObject(rightViewer.currentMesh);
            let position;

            if (selectedAxis === 'y') {
                position = box.min.y + (box.max.y - box.min.y) * percentage;
            } else {
                position = box.min.x + (box.max.x - box.min.x) * percentage;
            }

            rightViewer.updateCrossSection(position);
            rightViewer.sectionHeight = position;

            // Update trim if enabled
            if (trimEnabled) {
                rightViewer.trimMesh(true);
            }
        }
    });

    // Toggle mesh visibility
    toggleMeshBtn.addEventListener('click', () => {
        meshVisible = !meshVisible;

        if (leftViewer) {
            leftViewer.toggleMeshVisibility(meshVisible);
        }
        if (rightViewer) {
            rightViewer.toggleMeshVisibility(meshVisible);
        }

        toggleMeshBtn.innerHTML = meshVisible ? 'üëÅÔ∏è Hide Mesh' : 'üëÅÔ∏è Show Mesh';
    });

    // Toggle section visibility
    toggleSectionBtn.addEventListener('click', () => {
        sectionVisible = !sectionVisible;

        if (leftViewer) {
            leftViewer.toggleSectionVisibility(sectionVisible);
        }
        if (rightViewer) {
            rightViewer.toggleSectionVisibility(sectionVisible);
        }

        toggleSectionBtn.innerHTML = sectionVisible ? '‚úÇÔ∏è Hide Section' : '‚úÇÔ∏è Show Section';
    });

    // Trim mesh button
    trimMeshBtn.addEventListener('click', () => {
        trimEnabled = !trimEnabled;

        if (leftViewer) {
            leftViewer.trimMesh(trimEnabled);
        }
        if (rightViewer) {
            rightViewer.trimMesh(trimEnabled);
        }

        trimMeshBtn.innerHTML = trimEnabled ? '‚Ü©Ô∏è Reset Trim' : '‚úÇÔ∏è Trim Mesh';
    });

    // Front view button
    frontViewBtn.addEventListener('click', () => {
        if (leftViewer && leftViewer.camera) {
            leftViewer.camera.position.set(0, 0, 10);
            leftViewer.camera.lookAt(0, 0, 0);
            leftViewer.controls.update();
        }
        if (rightViewer && rightViewer.camera) {
            rightViewer.camera.position.set(0, 0, 10);
            rightViewer.camera.lookAt(0, 0, 0);
            rightViewer.controls.update();
        }
    });

    // Toggle rulers visibility
    toggleRulersBtn.addEventListener('click', () => {
        rulersVisible = !rulersVisible;

        if (leftViewer && leftViewer.rulers.vertical) {
            leftViewer.rulers.vertical.visible = rulersVisible;
            leftViewer.rulers.horizontal.visible = rulersVisible;
        }
        if (rightViewer && rightViewer.rulers.vertical) {
            rightViewer.rulers.vertical.visible = rulersVisible;
            rightViewer.rulers.horizontal.visible = rulersVisible;
        }

        toggleRulersBtn.innerHTML = rulersVisible ? 'üìè Hide Rulers' : 'üìè Show Rulers';
    });

    // Axis selection radio buttons
    const axisRadios = document.getElementsByName('section-axis');
    axisRadios.forEach(radio => {
        radio.addEventListener('change', (e) => {
            const axis = e.target.value;

            if (leftViewer) {
                leftViewer.sectionAxis = axis;
                // Update section with current position
                if (leftViewer.sectionHeight !== 0) {
                    leftViewer.updateCrossSection(leftViewer.sectionHeight);
                }
            }
            if (rightViewer) {
                rightViewer.sectionAxis = axis;
                // Update section with current position
                if (rightViewer.sectionHeight !== 0) {
                    rightViewer.updateCrossSection(rightViewer.sectionHeight);
                }
            }
        });
    });
});

function displaySimilarity(data) {
    // Backend returns 'overall_similarity', not 'similarity'
    const score = ((data.overall_similarity || 0) * 100).toFixed(1);
    document.getElementById('similarity-score').textContent = score;
    document.getElementById('similarity-progress').style.width = score + '%';

    const featureComparisonDiv = document.getElementById('feature-comparison');
    featureComparisonDiv.innerHTML = '<h5>Feature Differences:</h5>';

    for (const [feature, featureData] of Object.entries(data.feature_differences || {})) {
        const item = document.createElement('div');
        item.className = 'feature-item';

        // featureData is an object with {artifact1, artifact2, difference, similarity}
        const diffValue = featureData.difference || 0;
        const similarity = featureData.similarity || 0;

        item.innerHTML = `
            <span>${feature}</span>
            <span>${(diffValue * 100).toFixed(1)}% diff (${(similarity * 100).toFixed(1)}% similar)</span>
        `;
        featureComparisonDiv.appendChild(item);
    }
}
</script>
{% endblock %}
